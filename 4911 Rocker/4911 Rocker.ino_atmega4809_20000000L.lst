
C:\Users\dan__\AppData\Local\Temp\VMBuilds\4911 Rocker\MegaCoreX_4809\Release/4911 Rocker.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	50 c0       	rjmp	.+160    	; 0xa2 <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	75 c0       	rjmp	.+234    	; 0xf0 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	73 c0       	rjmp	.+230    	; 0xf0 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	71 c0       	rjmp	.+226    	; 0xf0 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	6f c0       	rjmp	.+222    	; 0xf0 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	6d c0       	rjmp	.+218    	; 0xf0 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	33 c6       	rjmp	.+3174   	; 0xc80 <__vector_6>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	69 c0       	rjmp	.+210    	; 0xf0 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	67 c0       	rjmp	.+206    	; 0xf0 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	65 c0       	rjmp	.+202    	; 0xf0 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	63 c0       	rjmp	.+198    	; 0xf0 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	61 c0       	rjmp	.+194    	; 0xf0 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	5f c0       	rjmp	.+190    	; 0xf0 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	5d c0       	rjmp	.+186    	; 0xf0 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	5b c0       	rjmp	.+182    	; 0xf0 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	59 c0       	rjmp	.+178    	; 0xf0 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	57 c0       	rjmp	.+174    	; 0xf0 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	55 c0       	rjmp	.+170    	; 0xf0 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	53 c0       	rjmp	.+166    	; 0xf0 <__bad_interrupt>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	51 c0       	rjmp	.+162    	; 0xf0 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	ab c5       	rjmp	.+2902   	; 0xba8 <__vector_20>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	4d c0       	rjmp	.+154    	; 0xf0 <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	4b c0       	rjmp	.+150    	; 0xf0 <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	49 c0       	rjmp	.+146    	; 0xf0 <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	c7 c5       	rjmp	.+2958   	; 0xbf0 <__vector_24>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	45 c0       	rjmp	.+138    	; 0xf0 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	43 c0       	rjmp	.+134    	; 0xf0 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	41 c0       	rjmp	.+130    	; 0xf0 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	3f c0       	rjmp	.+126    	; 0xf0 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	51 c5       	rjmp	.+2722   	; 0xb18 <__vector_29>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	3b c0       	rjmp	.+118    	; 0xf0 <__bad_interrupt>
      7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
      7c:	39 c0       	rjmp	.+114    	; 0xf0 <__bad_interrupt>
      7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
      80:	37 c0       	rjmp	.+110    	; 0xf0 <__bad_interrupt>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	35 c0       	rjmp	.+106    	; 0xf0 <__bad_interrupt>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	d7 c5       	rjmp	.+2990   	; 0xc38 <__vector_34>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	69 c5       	rjmp	.+2770   	; 0xb60 <__vector_35>
      8e:	00 00       	nop
../../../../crt1/gcrt1.S:102
      90:	1b c5       	rjmp	.+2614   	; 0xac8 <__vector_36>
      92:	00 00       	nop
../../../../crt1/gcrt1.S:103
      94:	eb c4       	rjmp	.+2518   	; 0xa6c <__vector_37>
      96:	00 00       	nop
../../../../crt1/gcrt1.S:104
      98:	c4 c4       	rjmp	.+2440   	; 0xa22 <__vector_38>
      9a:	00 00       	nop
../../../../crt1/gcrt1.S:105
      9c:	29 c0       	rjmp	.+82     	; 0xf0 <__bad_interrupt>
	...

000000a0 <__ctors_start>:
__trampolines_start():
      a0:	8a 06       	cpc	r8, r26

000000a2 <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      a2:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      a4:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      a6:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      a8:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      aa:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
      ac:	de bf       	out	0x3e, r29	; 62

000000ae <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      ae:	18 e2       	ldi	r17, 0x28	; 40
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      b0:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      b2:	b8 e2       	ldi	r27, 0x28	; 40
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      b4:	e5 e7       	ldi	r30, 0x75	; 117
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      b6:	f8 e1       	ldi	r31, 0x18	; 24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      b8:	02 c0       	rjmp	.+4      	; 0xbe <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      ba:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      bc:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      be:	a8 30       	cpi	r26, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      c0:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      c2:	d9 f7       	brne	.-10     	; 0xba <__do_copy_data+0xc>

000000c4 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      c4:	29 e2       	ldi	r18, 0x29	; 41
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      c6:	a8 e0       	ldi	r26, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      c8:	b8 e2       	ldi	r27, 0x28	; 40
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      ca:	01 c0       	rjmp	.+2      	; 0xce <.do_clear_bss_start>

000000cc <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      cc:	1d 92       	st	X+, r1

000000ce <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      ce:	a0 37       	cpi	r26, 0x70	; 112
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      d0:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      d2:	e1 f7       	brne	.-8      	; 0xcc <.do_clear_bss_loop>

000000d4 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      d4:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      d6:	c1 e5       	ldi	r28, 0x51	; 81
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      d8:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      da:	04 c0       	rjmp	.+8      	; 0xe4 <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      dc:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      de:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
      e0:	0e 94 c1 0b 	call	0x1782	; 0x1782 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
      e4:	c0 35       	cpi	r28, 0x50	; 80
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
      e6:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
      e8:	c9 f7       	brne	.-14     	; 0xdc <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
      ea:	79 d6       	rcall	.+3314   	; 0xdde <main>
../../../../crt1/gcrt1.S:315
      ec:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <_exit>

000000f0 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
      f0:	87 cf       	rjmp	.-242    	; 0x0 <__vectors>

000000f2 <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:295
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC
  {
    head = _tx_buffer_head;
      f2:	fc 01       	movw	r30, r24
      f4:	50 8d       	ldd	r21, Z+24	; 0x18
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:296
    tail = _tx_buffer_tail;
      f6:	41 8d       	ldd	r20, Z+25	; 0x19
      f8:	25 2f       	mov	r18, r21
      fa:	30 e0       	ldi	r19, 0x00	; 0
      fc:	84 2f       	mov	r24, r20
      fe:	90 e0       	ldi	r25, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:298
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     100:	82 1b       	sub	r24, r18
     102:	93 0b       	sbc	r25, r19
     104:	54 17       	cp	r21, r20
     106:	10 f0       	brcs	.+4      	; 0x10c <__EEPROM_REGION_LENGTH__+0xc>
     108:	cf 96       	adiw	r24, 0x3f	; 63
     10a:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:299
  return tail - head - 1;
     10c:	01 97       	sbiw	r24, 0x01	; 1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:300
}
     10e:	08 95       	ret

00000110 <UartClass::read()>:
_ZN9UartClass4readEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:274
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void)
{
     110:	fc 01       	movw	r30, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:276
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail)
     112:	96 89       	ldd	r25, Z+22	; 0x16
     114:	87 89       	ldd	r24, Z+23	; 0x17
     116:	98 17       	cp	r25, r24
     118:	61 f0       	breq	.+24     	; 0x132 <UartClass::read()+0x22>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:282
  {
    return -1;
  }
  else
  {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     11a:	a7 89       	ldd	r26, Z+23	; 0x17
     11c:	ae 0f       	add	r26, r30
     11e:	bf 2f       	mov	r27, r31
     120:	b1 1d       	adc	r27, r1
     122:	5d 96       	adiw	r26, 0x1d	; 29
     124:	8c 91       	ld	r24, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:283
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     126:	97 89       	ldd	r25, Z+23	; 0x17
     128:	9f 5f       	subi	r25, 0xFF	; 255
     12a:	9f 73       	andi	r25, 0x3F	; 63
     12c:	97 8b       	std	Z+23, r25	; 0x17
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:284
    return c;
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:278
int UartClass::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail)
  {
    return -1;
     132:	8f ef       	ldi	r24, 0xFF	; 255
     134:	9f ef       	ldi	r25, 0xFF	; 255
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:286
  {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     136:	08 95       	ret

00000138 <UartClass::peek()>:
_ZN9UartClass4peekEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:262
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void)
{
     138:	fc 01       	movw	r30, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:263
  if (_rx_buffer_head == _rx_buffer_tail)
     13a:	96 89       	ldd	r25, Z+22	; 0x16
     13c:	87 89       	ldd	r24, Z+23	; 0x17
     13e:	98 17       	cp	r25, r24
     140:	31 f0       	breq	.+12     	; 0x14e <UartClass::peek()+0x16>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:269
  {
    return -1;
  }
  else
  {
    return _rx_buffer[_rx_buffer_tail];
     142:	87 89       	ldd	r24, Z+23	; 0x17
     144:	e8 0f       	add	r30, r24
     146:	f1 1d       	adc	r31, r1
     148:	85 8d       	ldd	r24, Z+29	; 0x1d
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:265

int UartClass::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail)
  {
    return -1;
     14e:	8f ef       	ldi	r24, 0xFF	; 255
     150:	9f ef       	ldi	r25, 0xFF	; 255
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:271
  }
  else
  {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     152:	08 95       	ret

00000154 <UartClass::available()>:
_ZN9UartClass9availableEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:257
  // Note: Does not change output pins
  _written = false;
}

int UartClass::available(void)
{
     154:	fc 01       	movw	r30, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:258
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     156:	96 89       	ldd	r25, Z+22	; 0x16
     158:	27 89       	ldd	r18, Z+23	; 0x17
     15a:	89 2f       	mov	r24, r25
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	80 5c       	subi	r24, 0xC0	; 192
     160:	9f 4f       	sbci	r25, 0xFF	; 255
     162:	82 1b       	sub	r24, r18
     164:	91 09       	sbc	r25, r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:259
}
     166:	8f 73       	andi	r24, 0x3F	; 63
     168:	99 27       	eor	r25, r25
     16a:	08 95       	ret

0000016c <UartClass::end()>:
_ZN9UartClass3endEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:240
  // Restore SREG content
  SREG = oldSREG;
}

void UartClass::end()
{
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
     170:	ec 01       	movw	r28, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:242
  // wait for transmission of outgoing data
  flush();
     172:	e8 81       	ld	r30, Y
     174:	f9 81       	ldd	r31, Y+1	; 0x01
     176:	06 80       	ldd	r0, Z+6	; 0x06
     178:	f7 81       	ldd	r31, Z+7	; 0x07
     17a:	e0 2d       	mov	r30, r0
     17c:	09 95       	icall
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:246

  // Disable receiver and transmitter as well as the RX complete and
  // data register empty interrupts.
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     17e:	ec 85       	ldd	r30, Y+12	; 0x0c
     180:	fd 85       	ldd	r31, Y+13	; 0x0d
     182:	86 81       	ldd	r24, Z+6	; 0x06
     184:	8f 73       	andi	r24, 0x3F	; 63
     186:	86 83       	std	Z+6, r24	; 0x06
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:247
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm);
     188:	ec 85       	ldd	r30, Y+12	; 0x0c
     18a:	fd 85       	ldd	r31, Y+13	; 0x0d
     18c:	85 81       	ldd	r24, Z+5	; 0x05
     18e:	8f 75       	andi	r24, 0x5F	; 95
     190:	85 83       	std	Z+5, r24	; 0x05
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:250

  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     192:	8f 89       	ldd	r24, Y+23	; 0x17
     194:	8e 8b       	std	Y+22, r24	; 0x16
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:253

  // Note: Does not change output pins
  _written = false;
     196:	1d 8a       	std	Y+21, r1	; 0x15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:254
}
     198:	df 91       	pop	r29
     19a:	cf 91       	pop	r28
     19c:	08 95       	ret

0000019e <UartClass::swap(unsigned char)>:
_ZN9UartClass4swapEh():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:161
  _pin_set = 0; // Default to standard
  return false;
}

bool UartClass::swap(uint8_t state)
{
     19e:	fc 01       	movw	r30, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:162
  if (state == 1) // Use alternative pin position
     1a0:	61 30       	cpi	r22, 0x01	; 1
     1a2:	19 f4       	brne	.+6      	; 0x1aa <UartClass::swap(unsigned char)+0xc>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:164
  {
    _pin_set = state;
     1a4:	64 8b       	std	Z+20, r22	; 0x14
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:170
    return true;
  }
  else if (state == 0) // Use default pin position
  {
    _pin_set = 0;
    return true;
     1a6:	81 e0       	ldi	r24, 0x01	; 1
     1a8:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:169
    _pin_set = state;
    return true;
  }
  else if (state == 0) // Use default pin position
  {
    _pin_set = 0;
     1aa:	14 8a       	std	Z+20, r1	; 0x14
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:167
  if (state == 1) // Use alternative pin position
  {
    _pin_set = state;
    return true;
  }
  else if (state == 0) // Use default pin position
     1ac:	66 23       	and	r22, r22
     1ae:	d9 f3       	breq	.-10     	; 0x1a6 <UartClass::swap(unsigned char)+0x8>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:175
    return true;
  }
  else // Invalid swap value. Use default position
  {
    _pin_set = 0;
    return false;
     1b0:	80 e0       	ldi	r24, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:177
  }
}
     1b2:	08 95       	ret

000001b4 <UartClass::pins(unsigned char, unsigned char)>:
_ZN9UartClass4pinsEhh():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:147

// Public Methods //////////////////////////////////////////////////////////////

// Invoke this function before 'begin' to define the pins used
bool UartClass::pins(uint8_t tx, uint8_t rx)
{
     1b4:	dc 01       	movw	r26, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:148
  for (_pin_set = 0; _pin_set < SERIAL_PIN_SETS; ++_pin_set)
     1b6:	54 96       	adiw	r26, 0x14	; 20
     1b8:	1c 92       	st	X, r1
     1ba:	54 97       	sbiw	r26, 0x14	; 20
     1bc:	54 96       	adiw	r26, 0x14	; 20
     1be:	8c 91       	ld	r24, X
     1c0:	54 97       	sbiw	r26, 0x14	; 20
     1c2:	82 30       	cpi	r24, 0x02	; 2
     1c4:	a0 f4       	brcc	.+40     	; 0x1ee <UartClass::pins(unsigned char, unsigned char)+0x3a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:150
  {
    if (tx == _hw_set[_pin_set].tx_pin && rx == _hw_set[_pin_set].rx_pin)
     1c6:	28 2f       	mov	r18, r24
     1c8:	30 e0       	ldi	r19, 0x00	; 0
     1ca:	f9 01       	movw	r30, r18
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e2 0f       	add	r30, r18
     1d2:	f3 1f       	adc	r31, r19
     1d4:	ea 0f       	add	r30, r26
     1d6:	fb 1f       	adc	r31, r27
     1d8:	97 85       	ldd	r25, Z+15	; 0x0f
     1da:	96 13       	cpse	r25, r22
     1dc:	03 c0       	rjmp	.+6      	; 0x1e4 <UartClass::pins(unsigned char, unsigned char)+0x30>
     1de:	96 85       	ldd	r25, Z+14	; 0x0e
     1e0:	94 17       	cp	r25, r20
     1e2:	49 f0       	breq	.+18     	; 0x1f6 <UartClass::pins(unsigned char, unsigned char)+0x42>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:148
// Public Methods //////////////////////////////////////////////////////////////

// Invoke this function before 'begin' to define the pins used
bool UartClass::pins(uint8_t tx, uint8_t rx)
{
  for (_pin_set = 0; _pin_set < SERIAL_PIN_SETS; ++_pin_set)
     1e4:	8f 5f       	subi	r24, 0xFF	; 255
     1e6:	54 96       	adiw	r26, 0x14	; 20
     1e8:	8c 93       	st	X, r24
     1ea:	54 97       	sbiw	r26, 0x14	; 20
     1ec:	e7 cf       	rjmp	.-50     	; 0x1bc <UartClass::pins(unsigned char, unsigned char)+0x8>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:156
    {
      // We are good, this set of pins is supported
      return true;
    }
  }
  _pin_set = 0; // Default to standard
     1ee:	54 96       	adiw	r26, 0x14	; 20
     1f0:	1c 92       	st	X, r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:157
  return false;
     1f2:	80 e0       	ldi	r24, 0x00	; 0
     1f4:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:153
  for (_pin_set = 0; _pin_set < SERIAL_PIN_SETS; ++_pin_set)
  {
    if (tx == _hw_set[_pin_set].tx_pin && rx == _hw_set[_pin_set].rx_pin)
    {
      // We are good, this set of pins is supported
      return true;
     1f6:	81 e0       	ldi	r24, 0x01	; 1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:158
    }
  }
  _pin_set = 0; // Default to standard
  return false;
}
     1f8:	08 95       	ret

000001fa <UartClass::_tx_data_empty_irq()>:
_ZN9UartClass18_tx_data_empty_irqEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:89
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_tx_data_empty_irq(void)
{
     1fa:	cf 93       	push	r28
     1fc:	df 93       	push	r29
     1fe:	fc 01       	movw	r30, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:91
  // Check if tx buffer already empty.
  if (_tx_buffer_head == _tx_buffer_tail)
     200:	90 8d       	ldd	r25, Z+24	; 0x18
     202:	81 8d       	ldd	r24, Z+25	; 0x19
     204:	c4 85       	ldd	r28, Z+12	; 0x0c
     206:	d5 85       	ldd	r29, Z+13	; 0x0d
     208:	98 13       	cpse	r25, r24
     20a:	06 c0       	rjmp	.+12     	; 0x218 <UartClass::_tx_data_empty_irq()+0x1e>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:94
  {
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     20c:	8d 81       	ldd	r24, Y+5	; 0x05
     20e:	8f 7d       	andi	r24, 0xDF	; 223
     210:	8d 83       	std	Y+5, r24	; 0x05
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:122
    {
      CPUINT.LVL1VEC = _prev_lvl1_interrupt_vect;
      _hwserial_dre_interrupt_elevated = 0;
    }
  }
}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:100
    return;
  }

  // There must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     218:	a1 8d       	ldd	r26, Z+25	; 0x19
     21a:	ae 0f       	add	r26, r30
     21c:	bf 2f       	mov	r27, r31
     21e:	b1 1d       	adc	r27, r1
     220:	a3 5a       	subi	r26, 0xA3	; 163
     222:	bf 4f       	sbci	r27, 0xFF	; 255
     224:	2c 91       	ld	r18, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:101
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     226:	81 8d       	ldd	r24, Z+25	; 0x19
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	01 96       	adiw	r24, 0x01	; 1
     22c:	8f 73       	andi	r24, 0x3F	; 63
     22e:	99 27       	eor	r25, r25
     230:	81 8f       	std	Z+25, r24	; 0x19
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:106

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  (*_hwserial_module).STATUS = USART_TXCIF_bm;
     232:	80 e4       	ldi	r24, 0x40	; 64
     234:	8c 83       	std	Y+4, r24	; 0x04
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:108

  (*_hwserial_module).TXDATAL = c;
     236:	a4 85       	ldd	r26, Z+12	; 0x0c
     238:	b5 85       	ldd	r27, Z+13	; 0x0d
     23a:	12 96       	adiw	r26, 0x02	; 2
     23c:	2c 93       	st	X, r18
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:110

  if (_tx_buffer_head == _tx_buffer_tail)
     23e:	90 8d       	ldd	r25, Z+24	; 0x18
     240:	81 8d       	ldd	r24, Z+25	; 0x19
     242:	98 13       	cpse	r25, r24
     244:	e6 cf       	rjmp	.-52     	; 0x212 <UartClass::_tx_data_empty_irq()+0x18>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:113
  {
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     246:	a4 85       	ldd	r26, Z+12	; 0x0c
     248:	b5 85       	ldd	r27, Z+13	; 0x0d
     24a:	15 96       	adiw	r26, 0x05	; 5
     24c:	8c 91       	ld	r24, X
     24e:	15 97       	sbiw	r26, 0x05	; 5
     250:	8f 7d       	andi	r24, 0xDF	; 223
     252:	15 96       	adiw	r26, 0x05	; 5
     254:	8c 93       	st	X, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:116

    //Take the DRE interrupt back no normal priority level if it has been elevated
    if (_hwserial_dre_interrupt_elevated)
     256:	83 8d       	ldd	r24, Z+27	; 0x1b
     258:	88 23       	and	r24, r24
     25a:	d9 f2       	breq	.-74     	; 0x212 <UartClass::_tx_data_empty_irq()+0x18>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:118
    {
      CPUINT.LVL1VEC = _prev_lvl1_interrupt_vect;
     25c:	84 8d       	ldd	r24, Z+28	; 0x1c
     25e:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x7f4113>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:119
      _hwserial_dre_interrupt_elevated = 0;
     262:	13 8e       	std	Z+27, r1	; 0x1b
     264:	d6 cf       	rjmp	.-84     	; 0x212 <UartClass::_tx_data_empty_irq()+0x18>

00000266 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:126
  }
}

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void)
{
     266:	dc 01       	movw	r26, r24
     268:	1c 96       	adiw	r26, 0x0c	; 12
     26a:	ed 91       	ld	r30, X+
     26c:	fc 91       	ld	r31, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:127
  if ((!(SREG & CPU_I_bm)) || (!((*_hwserial_module).CTRLA & USART_DREIE_bm)))
     26e:	0f b6       	in	r0, 0x3f	; 63
     270:	07 fe       	sbrs	r0, 7
     272:	03 c0       	rjmp	.+6      	; 0x27a <UartClass::_poll_tx_data_empty()+0x14>
     274:	25 81       	ldd	r18, Z+5	; 0x05
     276:	25 fd       	sbrc	r18, 5
     278:	03 c0       	rjmp	.+6      	; 0x280 <UartClass::_poll_tx_data_empty()+0x1a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:135
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.

    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm)
     27a:	24 81       	ldd	r18, Z+4	; 0x04
     27c:	25 fd       	sbrc	r18, 5
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:137
    {
      _tx_data_empty_irq();
     27e:	bd cf       	rjmp	.-134    	; 0x1fa <UartClass::_tx_data_empty_irq()>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:141
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
}
     280:	08 95       	ret

00000282 <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:336
  // If we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}

size_t UartClass::write(uint8_t c)
{
     282:	ef 92       	push	r14
     284:	ff 92       	push	r15
     286:	0f 93       	push	r16
     288:	1f 93       	push	r17
     28a:	cf 93       	push	r28
     28c:	df 93       	push	r29
     28e:	ec 01       	movw	r28, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:337
  _written = true;
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	8d 8b       	std	Y+21, r24	; 0x15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:343

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm))
     294:	98 8d       	ldd	r25, Y+24	; 0x18
     296:	89 8d       	ldd	r24, Y+25	; 0x19
     298:	98 13       	cpse	r25, r24
     29a:	1c c0       	rjmp	.+56     	; 0x2d4 <UartClass::write(unsigned char)+0x52>
     29c:	ac 85       	ldd	r26, Y+12	; 0x0c
     29e:	bd 85       	ldd	r27, Y+13	; 0x0d
     2a0:	14 96       	adiw	r26, 0x04	; 4
     2a2:	8c 91       	ld	r24, X
     2a4:	14 97       	sbiw	r26, 0x04	; 4
     2a6:	85 ff       	sbrs	r24, 5
     2a8:	15 c0       	rjmp	.+42     	; 0x2d4 <UartClass::write(unsigned char)+0x52>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:345
  {
    (*_hwserial_module).TXDATAL = c;
     2aa:	12 96       	adiw	r26, 0x02	; 2
     2ac:	6c 93       	st	X, r22
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:346
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     2ae:	ac 85       	ldd	r26, Y+12	; 0x0c
     2b0:	bd 85       	ldd	r27, Y+13	; 0x0d
     2b2:	80 e4       	ldi	r24, 0x40	; 64
     2b4:	14 96       	adiw	r26, 0x04	; 4
     2b6:	8c 93       	st	X, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:350

    // Make sure data register empty interrupt is disabled to avoid
    // that the interrupt handler is called in this situation
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     2b8:	ec 85       	ldd	r30, Y+12	; 0x0c
     2ba:	fd 85       	ldd	r31, Y+13	; 0x0d
     2bc:	85 81       	ldd	r24, Z+5	; 0x05
     2be:	8f 7d       	andi	r24, 0xDF	; 223
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:380

  _tx_buffer[_tx_buffer_head] = c;
  _tx_buffer_head = i;

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     2c0:	85 83       	std	Z+5, r24	; 0x05
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:383

  return 1;
}
     2c2:	81 e0       	ldi	r24, 0x01	; 1
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	1f 91       	pop	r17
     2cc:	0f 91       	pop	r16
     2ce:	ff 90       	pop	r15
     2d0:	ef 90       	pop	r14
     2d2:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:357
    return 1;
  }

  //Check if we are inside an ISR already (could be from by a source other than UART),
  // in which case the UART ISRs will be blocked.
  if (CPUINT.STATUS & CPUINT_LVL0EX_bm)
     2d4:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7f4111>
     2d8:	80 ff       	sbrs	r24, 0
     2da:	08 c0       	rjmp	.+16     	; 0x2ec <UartClass::write(unsigned char)+0x6a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:361
  {
    //Elevate the priority level of the Data Register Empty Interrupt vector
    //and copy whatever vector number that might be in the register already.
    _prev_lvl1_interrupt_vect = CPUINT.LVL1VEC;
     2dc:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <__TEXT_REGION_LENGTH__+0x7f4113>
     2e0:	8c 8f       	std	Y+28, r24	; 0x1c
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:362
    CPUINT.LVL1VEC = _hwserial_dre_interrupt_vect_num;
     2e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     2e4:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x7f4113>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:364

    _hwserial_dre_interrupt_elevated = 1;
     2e8:	81 e0       	ldi	r24, 0x01	; 1
     2ea:	8b 8f       	std	Y+27, r24	; 0x1b
     2ec:	f6 2e       	mov	r15, r22
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:367
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     2ee:	08 8d       	ldd	r16, Y+24	; 0x18
     2f0:	10 e0       	ldi	r17, 0x00	; 0
     2f2:	0f 5f       	subi	r16, 0xFF	; 255
     2f4:	1f 4f       	sbci	r17, 0xFF	; 255
     2f6:	0f 73       	andi	r16, 0x3F	; 63
     2f8:	11 27       	eor	r17, r17
     2fa:	e0 2e       	mov	r14, r16
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:371

  //If the output buffer is full, there's nothing for it other than to
  //wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail)
     2fc:	89 8d       	ldd	r24, Y+25	; 0x19
     2fe:	8e 11       	cpse	r24, r14
     300:	03 c0       	rjmp	.+6      	; 0x308 <UartClass::write(unsigned char)+0x86>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:373
  {
    _poll_tx_data_empty();
     302:	ce 01       	movw	r24, r28
     304:	b0 df       	rcall	.-160    	; 0x266 <UartClass::_poll_tx_data_empty()>
     306:	fa cf       	rjmp	.-12     	; 0x2fc <UartClass::write(unsigned char)+0x7a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:376
  }

  _tx_buffer[_tx_buffer_head] = c;
     308:	e8 8d       	ldd	r30, Y+24	; 0x18
     30a:	ec 0f       	add	r30, r28
     30c:	fd 2f       	mov	r31, r29
     30e:	f1 1d       	adc	r31, r1
     310:	e3 5a       	subi	r30, 0xA3	; 163
     312:	ff 4f       	sbci	r31, 0xFF	; 255
     314:	f0 82       	st	Z, r15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:377
  _tx_buffer_head = i;
     316:	08 8f       	std	Y+24, r16	; 0x18
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:380

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     318:	ec 85       	ldd	r30, Y+12	; 0x0c
     31a:	fd 85       	ldd	r31, Y+13	; 0x0d
     31c:	85 81       	ldd	r24, Z+5	; 0x05
     31e:	80 62       	ori	r24, 0x20	; 32
     320:	cf cf       	rjmp	.-98     	; 0x2c0 <UartClass::write(unsigned char)+0x3e>

00000322 <UartClass::flush()>:
_ZN9UartClass5flushEv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:303
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void UartClass::flush()
{
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:307
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     326:	fc 01       	movw	r30, r24
     328:	25 89       	ldd	r18, Z+21	; 0x15
     32a:	22 23       	and	r18, r18
     32c:	c1 f0       	breq	.+48     	; 0x35e <UartClass::flush()+0x3c>
     32e:	ec 01       	movw	r28, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:314
    return;
  }

  //Check if we are inside an ISR already (e.g. connected to a different peripheral then UART), in which case the UART ISRs will not be called.
  //Temporarily elevate the DRE interrupt to allow it to run.
  if (CPUINT.STATUS & CPUINT_LVL0EX_bm)
     330:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7f4111>
     334:	80 ff       	sbrs	r24, 0
     336:	08 c0       	rjmp	.+16     	; 0x348 <UartClass::flush()+0x26>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:318
  {
    //Elevate the priority level of the Data Register Empty Interrupt vector
    //and copy whatever vector number that might be in the register already.
    _prev_lvl1_interrupt_vect = CPUINT.LVL1VEC;
     338:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <__TEXT_REGION_LENGTH__+0x7f4113>
     33c:	84 8f       	std	Z+28, r24	; 0x1c
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:319
    CPUINT.LVL1VEC = _hwserial_dre_interrupt_vect_num;
     33e:	82 8d       	ldd	r24, Z+26	; 0x1a
     340:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x7f4113>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:321

    _hwserial_dre_interrupt_elevated = 1;
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	83 8f       	std	Z+27, r24	; 0x1b
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:325
  }

  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm)))
     348:	ec 85       	ldd	r30, Y+12	; 0x0c
     34a:	fd 85       	ldd	r31, Y+13	; 0x0d
     34c:	85 81       	ldd	r24, Z+5	; 0x05
     34e:	85 fd       	sbrc	r24, 5
     350:	03 c0       	rjmp	.+6      	; 0x358 <UartClass::flush()+0x36>
     352:	84 81       	ldd	r24, Z+4	; 0x04
     354:	86 fd       	sbrc	r24, 6
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:329
  {
    // If interrupts are globally disabled or the and DR empty interrupt is disabled,
    // poll the "data register empty" interrupt flag to prevent deadlock
    _poll_tx_data_empty();
     356:	03 c0       	rjmp	.+6      	; 0x35e <UartClass::flush()+0x3c>
     358:	ce 01       	movw	r24, r28
     35a:	85 df       	rcall	.-246    	; 0x266 <UartClass::_poll_tx_data_empty()>
     35c:	f5 cf       	rjmp	.-22     	; 0x348 <UartClass::flush()+0x26>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:333
  }
  // If we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:65

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available()
{
  return Serial.available();
     362:	08 95       	ret

00000364 <Serial0_available()>:
_Z17Serial0_availablev():
     364:	8b e7       	ldi	r24, 0x7B	; 123
     366:	98 e2       	ldi	r25, 0x28	; 40
     368:	f5 de       	rcall	.-534    	; 0x154 <UartClass::available()>
     36a:	21 e0       	ldi	r18, 0x01	; 1
     36c:	89 2b       	or	r24, r25
     36e:	09 f4       	brne	.+2      	; 0x372 <Serial0_available()+0xe>
     370:	20 e0       	ldi	r18, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:66
}
     372:	82 2f       	mov	r24, r18
     374:	08 95       	ret

00000376 <serialEventRun()>:
_Z14serialEventRunv():
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	89 2b       	or	r24, r25
     37c:	21 f0       	breq	.+8      	; 0x386 <serialEventRun()+0x10>
     37e:	f2 df       	rcall	.-28     	; 0x364 <Serial0_available()>
     380:	81 11       	cpse	r24, r1
     382:	0e 94 00 00 	call	0	; 0x0 <__vectors>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:69
#endif
#if defined(HAVE_HWSERIAL1)
  if (Serial1_available && serialEvent1 && Serial1_available()) serialEvent1();
     386:	80 e0       	ldi	r24, 0x00	; 0
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	89 2b       	or	r24, r25
     38c:	49 f0       	breq	.+18     	; 0x3a0 <serialEventRun()+0x2a>
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	89 2b       	or	r24, r25
     394:	29 f0       	breq	.+10     	; 0x3a0 <serialEventRun()+0x2a>
     396:	0e 94 00 00 	call	0	; 0x0 <__vectors>
     39a:	81 11       	cpse	r24, r1
     39c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:72
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
     3a0:	80 e0       	ldi	r24, 0x00	; 0
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	89 2b       	or	r24, r25
     3a6:	49 f0       	breq	.+18     	; 0x3ba <serialEventRun()+0x44>
     3a8:	80 e0       	ldi	r24, 0x00	; 0
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	89 2b       	or	r24, r25
     3ae:	29 f0       	breq	.+10     	; 0x3ba <serialEventRun()+0x44>
     3b0:	0e 94 00 00 	call	0	; 0x0 <__vectors>
     3b4:	81 11       	cpse	r24, r1
     3b6:	0e 94 00 00 	call	0	; 0x0 <__vectors>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:75
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
     3ba:	80 e0       	ldi	r24, 0x00	; 0
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	89 2b       	or	r24, r25
     3c0:	49 f0       	breq	.+18     	; 0x3d4 <serialEventRun()+0x5e>
     3c2:	80 e0       	ldi	r24, 0x00	; 0
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	89 2b       	or	r24, r25
     3c8:	29 f0       	breq	.+10     	; 0x3d4 <serialEventRun()+0x5e>
     3ca:	0e 94 00 00 	call	0	; 0x0 <__vectors>
     3ce:	81 11       	cpse	r24, r1
     3d0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:77
#endif
}
     3d4:	08 95       	ret

000003d6 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:30

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     3d6:	af 92       	push	r10
     3d8:	bf 92       	push	r11
     3da:	cf 92       	push	r12
     3dc:	df 92       	push	r13
     3de:	ef 92       	push	r14
     3e0:	ff 92       	push	r15
     3e2:	0f 93       	push	r16
     3e4:	1f 93       	push	r17
     3e6:	cf 93       	push	r28
     3e8:	df 93       	push	r29
     3ea:	6c 01       	movw	r12, r24
     3ec:	7b 01       	movw	r14, r22
     3ee:	8b 01       	movw	r16, r22
     3f0:	04 0f       	add	r16, r20
     3f2:	15 1f       	adc	r17, r21
     3f4:	eb 01       	movw	r28, r22
     3f6:	5e 01       	movw	r10, r28
     3f8:	ae 18       	sub	r10, r14
     3fa:	bf 08       	sbc	r11, r15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:32
  size_t n = 0;
  while (size--)
     3fc:	c0 17       	cp	r28, r16
     3fe:	d1 07       	cpc	r29, r17
     400:	59 f0       	breq	.+22     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:34
  {
    if (write(*buffer++))
     402:	69 91       	ld	r22, Y+
     404:	d6 01       	movw	r26, r12
     406:	ed 91       	ld	r30, X+
     408:	fc 91       	ld	r31, X
     40a:	01 90       	ld	r0, Z+
     40c:	f0 81       	ld	r31, Z
     40e:	e0 2d       	mov	r30, r0
     410:	c6 01       	movw	r24, r12
     412:	09 95       	icall
     414:	89 2b       	or	r24, r25
     416:	79 f7       	brne	.-34     	; 0x3f6 <Print::write(unsigned char const*, unsigned int)+0x20>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:40
      n++;
    else
      break;
  }
  return n;
}
     418:	c5 01       	movw	r24, r10
     41a:	df 91       	pop	r29
     41c:	cf 91       	pop	r28
     41e:	1f 91       	pop	r17
     420:	0f 91       	pop	r16
     422:	ff 90       	pop	r15
     424:	ef 90       	pop	r14
     426:	df 90       	pop	r13
     428:	cf 90       	pop	r12
     42a:	bf 90       	pop	r11
     42c:	af 90       	pop	r10
     42e:	08 95       	ret

00000430 <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART.h:174
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() { return true; }
     430:	81 e0       	ldi	r24, 0x01	; 1
     432:	08 95       	ret

00000434 <digitalWrite.part.2>:
digitalWrite.part.2():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:137
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     434:	28 2f       	mov	r18, r24
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	f9 01       	movw	r30, r18
     43a:	e7 52       	subi	r30, 0x27	; 39
     43c:	f8 4a       	sbci	r31, 0xA8	; 168
     43e:	40 81       	ld	r20, Z
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:138
  if (bit_mask == NOT_A_PIN)
     440:	4f 3f       	cpi	r20, 0xFF	; 255
     442:	09 f4       	brne	.+2      	; 0x446 <digitalWrite.part.2+0x12>
     444:	54 c0       	rjmp	.+168    	; 0x4ee <digitalWrite.part.2+0xba>
turnOffPWM():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:97
static void turnOffPWM(uint8_t pin)
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimer(pin);
     446:	8e 32       	cpi	r24, 0x2E	; 46
     448:	58 f4       	brcc	.+22     	; 0x460 <digitalWrite.part.2+0x2c>
     44a:	f9 01       	movw	r30, r18
     44c:	e0 55       	subi	r30, 0x50	; 80
     44e:	f8 4a       	sbci	r31, 0xA8	; 168
     450:	e0 81       	ld	r30, Z
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:98
  if (timer == NOT_ON_TIMER)
     452:	ee 23       	and	r30, r30
     454:	29 f0       	breq	.+10     	; 0x460 <digitalWrite.part.2+0x2c>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:104
    return;

  uint8_t bit_pos;
  TCB_t *timerB;

  switch (timer)
     456:	e1 30       	cpi	r30, 0x01	; 1
     458:	99 f0       	breq	.+38     	; 0x480 <digitalWrite.part.2+0x4c>
     45a:	10 f0       	brcs	.+4      	; 0x460 <digitalWrite.part.2+0x2c>
     45c:	e6 30       	cpi	r30, 0x06	; 6
     45e:	20 f1       	brcs	.+72     	; 0x4a8 <digitalWrite.part.2+0x74>
digitalWrite.part.2():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:150
  turnOffPWM(pin);

  /* Assuming the direction is already output !! */

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     460:	f9 01       	movw	r30, r18
     462:	ee 5f       	subi	r30, 0xFE	; 254
     464:	f7 4a       	sbci	r31, 0xA7	; 167
     466:	e0 81       	ld	r30, Z
     468:	a0 e2       	ldi	r26, 0x20	; 32
     46a:	ea 9f       	mul	r30, r26
     46c:	f0 01       	movw	r30, r0
     46e:	11 24       	eor	r1, r1
     470:	fc 5f       	subi	r31, 0xFC	; 252
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:153

  /* Output direction */
  if (port->DIR & bit_mask)
     472:	80 81       	ld	r24, Z
     474:	84 23       	and	r24, r20
     476:	41 f1       	breq	.+80     	; 0x4c8 <digitalWrite.part.2+0x94>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:156
  {
    /* Set output to value */
    if (val == LOW)
     478:	61 11       	cpse	r22, r1
     47a:	20 c0       	rjmp	.+64     	; 0x4bc <digitalWrite.part.2+0x88>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:158
    { /* If LOW */
      port->OUTCLR = bit_mask;
     47c:	46 83       	std	Z+6, r20	; 0x06
     47e:	08 95       	ret
turnOffPWM():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:109
  switch (timer)
  {
    /* TCA0 */
    case TIMERA0:
      /* Bit position will give output channel */
      bit_pos = digitalPinToBitPosition(pin);
     480:	f9 01       	movw	r30, r18
     482:	e5 5d       	subi	r30, 0xD5	; 213
     484:	f7 4a       	sbci	r31, 0xA7	; 167
     486:	50 81       	ld	r21, Z
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:112

      /* Disable corresponding channel */
      if (bit_pos >= 3) ++bit_pos; /* Upper 3 bits are shifted by 1 */
     488:	53 30       	cpi	r21, 0x03	; 3
     48a:	08 f0       	brcs	.+2      	; 0x48e <digitalWrite.part.2+0x5a>
     48c:	5f 5f       	subi	r21, 0xFF	; 255
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:113
      TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_LCMP0EN_bp + bit_pos));
     48e:	70 91 01 0a 	lds	r23, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f4a01>
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	01 c0       	rjmp	.+2      	; 0x49a <digitalWrite.part.2+0x66>
     498:	88 0f       	add	r24, r24
     49a:	5a 95       	dec	r21
     49c:	ea f7       	brpl	.-6      	; 0x498 <digitalWrite.part.2+0x64>
     49e:	80 95       	com	r24
     4a0:	87 23       	and	r24, r23
     4a2:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f4a01>
     4a6:	dc cf       	rjmp	.-72     	; 0x460 <digitalWrite.part.2+0x2c>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:123
    case TIMERB0:
    case TIMERB1:
    case TIMERB2:
    case TIMERB3:

      timerB = (TCB_t *)&TCB0 + (timer - TIMERB0);
     4a8:	80 e1       	ldi	r24, 0x10	; 16
     4aa:	e8 9f       	mul	r30, r24
     4ac:	f0 01       	movw	r30, r0
     4ae:	11 24       	eor	r1, r1
     4b0:	e0 5a       	subi	r30, 0xA0	; 160
     4b2:	f5 4f       	sbci	r31, 0xF5	; 245
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:126

      /* Disable TCB compare channel */
      timerB->CTRLB &= ~(TCB_CCMPEN_bm);
     4b4:	81 81       	ldd	r24, Z+1	; 0x01
     4b6:	8f 7e       	andi	r24, 0xEF	; 239
     4b8:	81 83       	std	Z+1, r24	; 0x01
     4ba:	d2 cf       	rjmp	.-92     	; 0x460 <digitalWrite.part.2+0x2c>
digitalWrite.part.2():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:160
    /* Set output to value */
    if (val == LOW)
    { /* If LOW */
      port->OUTCLR = bit_mask;
    }
    else if (val == CHANGE)
     4bc:	64 30       	cpi	r22, 0x04	; 4
     4be:	11 f4       	brne	.+4      	; 0x4c4 <digitalWrite.part.2+0x90>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:162
    { /* If TOGGLE */
      port->OUTTGL = bit_mask;
     4c0:	47 83       	std	Z+7, r20	; 0x07
     4c2:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:167
      /* If HIGH OR  > TOGGLE  */
    }
    else
    {
      port->OUTSET = bit_mask;
     4c4:	45 83       	std	Z+5, r20	; 0x05
     4c6:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:180
    pull up is enabled if this function is called.
    Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     4c8:	25 5d       	subi	r18, 0xD5	; 213
     4ca:	37 4a       	sbci	r19, 0xA7	; 167
     4cc:	d9 01       	movw	r26, r18
     4ce:	8c 91       	ld	r24, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:183

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     4d0:	30 97       	sbiw	r30, 0x00	; 0
     4d2:	71 f0       	breq	.+28     	; 0x4f0 <digitalWrite.part.2+0xbc>
     4d4:	8f 3f       	cpi	r24, 0xFF	; 255
     4d6:	61 f0       	breq	.+24     	; 0x4f0 <digitalWrite.part.2+0xbc>
     4d8:	70 96       	adiw	r30, 0x10	; 16
     4da:	e8 0f       	add	r30, r24
     4dc:	f1 1d       	adc	r31, r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:186

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     4de:	9f b7       	in	r25, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:187
    cli();
     4e0:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:192

    if (val == LOW)
    {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     4e2:	80 81       	ld	r24, Z
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:189

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW)
     4e4:	61 11       	cpse	r22, r1
     4e6:	07 c0       	rjmp	.+14     	; 0x4f6 <digitalWrite.part.2+0xc2>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:192
    {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     4e8:	87 7f       	andi	r24, 0xF7	; 247
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:197
    }
    else
    {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     4ea:	80 83       	st	Z, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:201
    }

    /* Restore system status */
    SREG = status;
     4ec:	9f bf       	out	0x3f, r25	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:203
  }
}
     4ee:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:183

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     4f0:	f0 e0       	ldi	r31, 0x00	; 0
     4f2:	e0 e0       	ldi	r30, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:197
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    }
    else
    {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     4f4:	f4 cf       	rjmp	.-24     	; 0x4de <digitalWrite.part.2+0xaa>
     4f6:	88 60       	ori	r24, 0x08	; 8
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:137
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     4f8:	f8 cf       	rjmp	.-16     	; 0x4ea <digitalWrite.part.2+0xb6>

000004fa <digitalWrite>:
digitalWrite():
     4fa:	8e 32       	cpi	r24, 0x2E	; 46
     4fc:	08 f4       	brcc	.+2      	; 0x500 <digitalWrite+0x6>
     4fe:	9a cf       	rjmp	.-204    	; 0x434 <digitalWrite.part.2>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:203
    }

    /* Restore system status */
    SREG = status;
  }
}
     500:	08 95       	ret

00000502 <MCP_DAC::swSPI_transfer(unsigned char) [clone .constprop.8]>:
_ZN7MCP_DAC14swSPI_transferEh.constprop.8():
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:324
  digitalWrite(_select, HIGH);
}


//  MSBFIRST
uint8_t MCP_DAC::swSPI_transfer(uint8_t val)
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	e8 2e       	mov	r14, r24
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:326
{
  uint8_t clk = _clock;
     510:	00 91 5a 29 	lds	r16, 0x295A	; 0x80295a <MCP+0x1>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:327
  uint8_t dao = _dataOut;
     514:	f0 90 59 29 	lds	r15, 0x2959	; 0x802959 <MCP>
     518:	c8 e0       	ldi	r28, 0x08	; 8
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:328
  for (uint8_t mask = 0x80; mask; mask >>= 1)
     51a:	d0 e0       	ldi	r29, 0x00	; 0
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:330
  {
    digitalWrite(dao, (val & mask));
     51c:	10 e8       	ldi	r17, 0x80	; 128
     51e:	6e 2d       	mov	r22, r14
     520:	61 23       	and	r22, r17
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:331
    digitalWrite(clk, HIGH);
     522:	8f 2d       	mov	r24, r15
     524:	ea df       	rcall	.-44     	; 0x4fa <digitalWrite>
     526:	61 e0       	ldi	r22, 0x01	; 1
     528:	80 2f       	mov	r24, r16
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:332
    digitalWrite(clk, LOW);
     52a:	e7 df       	rcall	.-50     	; 0x4fa <digitalWrite>
     52c:	60 e0       	ldi	r22, 0x00	; 0
     52e:	80 2f       	mov	r24, r16
     530:	e4 df       	rcall	.-56     	; 0x4fa <digitalWrite>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:328
//  MSBFIRST
uint8_t MCP_DAC::swSPI_transfer(uint8_t val)
{
  uint8_t clk = _clock;
  uint8_t dao = _dataOut;
  for (uint8_t mask = 0x80; mask; mask >>= 1)
     532:	16 95       	lsr	r17
     534:	21 97       	sbiw	r28, 0x01	; 1
     536:	99 f7       	brne	.-26     	; 0x51e <MCP_DAC::swSPI_transfer(unsigned char) [clone .constprop.8]+0x1c>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:335
    digitalWrite(dao, (val & mask));
    digitalWrite(clk, HIGH);
    digitalWrite(clk, LOW);
  }
  return 0;
}
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	df 91       	pop	r29
     53c:	cf 91       	pop	r28
     53e:	1f 91       	pop	r17
     540:	0f 91       	pop	r16
     542:	ff 90       	pop	r15
     544:	ef 90       	pop	r14
     546:	08 95       	ret

00000548 <pinMode.part.1>:
pinMode.part.1():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:29

#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:31
{
  uint8_t bit_mask = digitalPinToBitMask(pin);
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	fc 01       	movw	r30, r24
     550:	e7 52       	subi	r30, 0x27	; 39
     552:	f8 4a       	sbci	r31, 0xA8	; 168
     554:	20 81       	ld	r18, Z
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:33

  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP))
     556:	2f 3f       	cpi	r18, 0xFF	; 255
     558:	61 f0       	breq	.+24     	; 0x572 <pinMode.part.1+0x2a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:36
    return;

  PORT_t *port = digitalPinToPortStruct(pin);
     55a:	fc 01       	movw	r30, r24
     55c:	ee 5f       	subi	r30, 0xFE	; 254
     55e:	f7 4a       	sbci	r31, 0xA7	; 167
     560:	e0 81       	ld	r30, Z
     562:	30 e2       	ldi	r19, 0x20	; 32
     564:	e3 9f       	mul	r30, r19
     566:	f0 01       	movw	r30, r0
     568:	11 24       	eor	r1, r1
     56a:	fc 5f       	subi	r31, 0xFC	; 252
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:40
  if (port == NULL)
    return;

  if (mode == OUTPUT)
     56c:	61 30       	cpi	r22, 0x01	; 1
     56e:	21 f4       	brne	.+8      	; 0x578 <pinMode.part.1+0x30>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:43
  {
    /* Configure direction as output */
    port->DIRSET = bit_mask;
     570:	21 83       	std	Z+1, r18	; 0x01
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:75
    }

    /* Restore state */
    SREG = status;
  }
}
     572:	df 91       	pop	r29
     574:	cf 91       	pop	r28
     576:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:48
    port->DIRSET = bit_mask;
  }
  else
  { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
     578:	85 5d       	subi	r24, 0xD5	; 213
     57a:	97 4a       	sbci	r25, 0xA7	; 167
     57c:	ec 01       	movw	r28, r24
     57e:	a8 81       	ld	r26, Y
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:50
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     580:	af 3f       	cpi	r26, 0xFF	; 255
     582:	69 f0       	breq	.+26     	; 0x59e <pinMode.part.1+0x56>
     584:	cf 01       	movw	r24, r30
     586:	40 96       	adiw	r24, 0x10	; 16
     588:	a8 0f       	add	r26, r24
     58a:	b9 2f       	mov	r27, r25
     58c:	b1 1d       	adc	r27, r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:53

    /* Save state */
    uint8_t status = SREG;
     58e:	9f b7       	in	r25, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:54
    cli();
     590:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:57

    /* Configure direction as input */
    port->DIRCLR = bit_mask;
     592:	22 83       	std	Z+2, r18	; 0x02
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:63

    /* Configure pull-up resistor */
    if (mode == INPUT_PULLUP)
    {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     594:	8c 91       	ld	r24, X
     596:	88 60       	ori	r24, 0x08	; 8
     598:	8c 93       	st	X, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:73
      /* Disable pull-up */
      *pin_ctrl_reg &= ~(PORT_PULLUPEN_bm);
    }

    /* Restore state */
    SREG = status;
     59a:	9f bf       	out	0x3f, r25	; 63
     59c:	ea cf       	rjmp	.-44     	; 0x572 <pinMode.part.1+0x2a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:50
  else
  { /* mode == INPUT or INPUT_PULLUP */

    uint8_t bit_pos = digitalPinToBitPosition(pin);
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     59e:	b0 e0       	ldi	r27, 0x00	; 0
     5a0:	a0 e0       	ldi	r26, 0x00	; 0
     5a2:	f5 cf       	rjmp	.-22     	; 0x58e <pinMode.part.1+0x46>

000005a4 <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:180
    return false;
  }
}

void UartClass::begin(unsigned long baud, uint16_t config)
{
     5a4:	af 92       	push	r10
     5a6:	bf 92       	push	r11
     5a8:	cf 92       	push	r12
     5aa:	df 92       	push	r13
     5ac:	ef 92       	push	r14
     5ae:	ff 92       	push	r15
     5b0:	0f 93       	push	r16
     5b2:	1f 93       	push	r17
     5b4:	cf 93       	push	r28
     5b6:	df 93       	push	r29
     5b8:	ec 01       	movw	r28, r24
     5ba:	6a 01       	movw	r12, r20
     5bc:	7b 01       	movw	r14, r22
     5be:	a2 2e       	mov	r10, r18
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:183
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_written)
     5c0:	8d 89       	ldd	r24, Y+21	; 0x15
     5c2:	88 23       	and	r24, r24
     5c4:	39 f0       	breq	.+14     	; 0x5d4 <UartClass::begin(unsigned long, unsigned int)+0x30>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:185
  {
    this->end();
     5c6:	e8 81       	ld	r30, Y
     5c8:	f9 81       	ldd	r31, Y+1	; 0x01
     5ca:	06 88       	ldd	r0, Z+22	; 0x16
     5cc:	f7 89       	ldd	r31, Z+23	; 0x17
     5ce:	e0 2d       	mov	r30, r0
     5d0:	ce 01       	movw	r24, r28
     5d2:	09 95       	icall
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:188
  }

  struct UartPinSet *set = &_hw_set[_pin_set];
     5d4:	0c 89       	ldd	r16, Y+20	; 0x14
     5d6:	10 e0       	ldi	r17, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:193

  int32_t baud_setting = 0;

  //Make sure global interrupts are disabled during initialization
  uint8_t oldSREG = SREG;
     5d8:	bf b6       	in	r11, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:194
  cli();
     5da:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:196

  baud_setting = (((8 * F_CPU) / baud) + 1) / 2;
     5dc:	60 e0       	ldi	r22, 0x00	; 0
     5de:	78 e6       	ldi	r23, 0x68	; 104
     5e0:	89 e8       	ldi	r24, 0x89	; 137
     5e2:	99 e0       	ldi	r25, 0x09	; 9
     5e4:	a7 01       	movw	r20, r14
     5e6:	96 01       	movw	r18, r12
     5e8:	0e 94 4a 0b 	call	0x1694	; 0x1694 <__udivmodsi4>
     5ec:	69 01       	movw	r12, r18
     5ee:	7a 01       	movw	r14, r20
     5f0:	8f ef       	ldi	r24, 0xFF	; 255
     5f2:	c8 1a       	sub	r12, r24
     5f4:	d8 0a       	sbc	r13, r24
     5f6:	e8 0a       	sbc	r14, r24
     5f8:	f8 0a       	sbc	r15, r24
     5fa:	f6 94       	lsr	r15
     5fc:	e7 94       	ror	r14
     5fe:	d7 94       	ror	r13
     600:	c7 94       	ror	r12
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:198
  // Disable CLK2X
  (*_hwserial_module).CTRLB &= (~USART_RXMODE_CLK2X_gc);
     602:	ec 85       	ldd	r30, Y+12	; 0x0c
     604:	fd 85       	ldd	r31, Y+13	; 0x0d
     606:	86 81       	ldd	r24, Z+6	; 0x06
     608:	8d 7f       	andi	r24, 0xFD	; 253
     60a:	86 83       	std	Z+6, r24	; 0x06
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:199
  (*_hwserial_module).CTRLB |= USART_RXMODE_NORMAL_gc;
     60c:	ec 85       	ldd	r30, Y+12	; 0x0c
     60e:	fd 85       	ldd	r31, Y+13	; 0x0d
     610:	86 81       	ldd	r24, Z+6	; 0x06
     612:	86 83       	std	Z+6, r24	; 0x06
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:201

  _written = false;
     614:	1d 8a       	std	Y+21, r1	; 0x15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:208
  int8_t sigrow_val = 0;

// Use error compensation if internal oscillator is used
#if !defined(USE_EXTERNAL_OSCILLATOR)
#if F_CPU == 20000000L
  sigrow_val = SIGROW.OSC20ERR5V;
     616:	a0 91 25 11 	lds	r26, 0x1125	; 0x801125 <__TEXT_REGION_LENGTH__+0x7f5125>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:214
#else
  sigrow_val = SIGROW.OSC16ERR5V;
#endif
#endif

  baud_setting += (baud_setting * sigrow_val) / 1024;
     61a:	0a 2e       	mov	r0, r26
     61c:	00 0c       	add	r0, r0
     61e:	bb 0b       	sbc	r27, r27
     620:	a7 01       	movw	r20, r14
     622:	96 01       	movw	r18, r12
     624:	0e 94 92 0b 	call	0x1724	; 0x1724 <__mulshisi3>
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	34 e0       	ldi	r19, 0x04	; 4
     62c:	40 e0       	ldi	r20, 0x00	; 0
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <__divmodsi4>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:217

  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     634:	ec 85       	ldd	r30, Y+12	; 0x0c
     636:	fd 85       	ldd	r31, Y+13	; 0x0d
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:214
#else
  sigrow_val = SIGROW.OSC16ERR5V;
#endif
#endif

  baud_setting += (baud_setting * sigrow_val) / 1024;
     638:	c2 0e       	add	r12, r18
     63a:	d3 1e       	adc	r13, r19
     63c:	e4 1e       	adc	r14, r20
     63e:	f5 1e       	adc	r15, r21
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:217

  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     640:	c0 86       	std	Z+8, r12	; 0x08
     642:	d1 86       	std	Z+9, r13	; 0x09
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:220

  // Set USART mode of operation
  (*_hwserial_module).CTRLC = config;
     644:	ec 85       	ldd	r30, Y+12	; 0x0c
     646:	fd 85       	ldd	r31, Y+13	; 0x0d
     648:	a7 82       	std	Z+7, r10	; 0x07
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:223

  // Enable transmitter and receiver
  (*_hwserial_module).CTRLB |= (USART_RXEN_bm | USART_TXEN_bm);
     64a:	ec 85       	ldd	r30, Y+12	; 0x0c
     64c:	fd 85       	ldd	r31, Y+13	; 0x0d
     64e:	86 81       	ldd	r24, Z+6	; 0x06
     650:	80 6c       	ori	r24, 0xC0	; 192
     652:	86 83       	std	Z+6, r24	; 0x06
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:225

  (*_hwserial_module).CTRLA |= USART_RXCIE_bm;
     654:	ec 85       	ldd	r30, Y+12	; 0x0c
     656:	fd 85       	ldd	r31, Y+13	; 0x0d
     658:	85 81       	ldd	r24, Z+5	; 0x05
     65a:	80 68       	ori	r24, 0x80	; 128
     65c:	85 83       	std	Z+5, r24	; 0x05
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:228

  // Let PORTMUX point to alternative UART pins as requested
  PORTMUX.USARTROUTEA = set->mux | (PORTMUX.USARTROUTEA & ~_hw_set[1].mux);
     65e:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7f45e2>
     662:	8b 89       	ldd	r24, Y+19	; 0x13
     664:	80 95       	com	r24
     666:	89 23       	and	r24, r25
     668:	78 01       	movw	r14, r16
     66a:	ee 0c       	add	r14, r14
     66c:	ff 1c       	adc	r15, r15
     66e:	f7 01       	movw	r30, r14
     670:	e0 0f       	add	r30, r16
     672:	f1 1f       	adc	r31, r17
     674:	ec 0f       	add	r30, r28
     676:	fd 1f       	adc	r31, r29
     678:	90 89       	ldd	r25, Z+16	; 0x10
     67a:	89 2b       	or	r24, r25
     67c:	80 93 e2 05 	sts	0x05E2, r24	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7f45e2>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:31
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  uint8_t bit_mask = digitalPinToBitMask(pin);
     680:	86 85       	ldd	r24, Z+14	; 0x0e
pinMode():
     682:	8e 32       	cpi	r24, 0x2E	; 46
     684:	10 f4       	brcc	.+4      	; 0x68a <UartClass::begin(unsigned long, unsigned int)+0xe6>
     686:	62 e0       	ldi	r22, 0x02	; 2
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:232

  // Set pin state for swapped UART pins
  pinMode(set->rx_pin, INPUT_PULLUP);
  digitalWrite(set->tx_pin, HIGH);
     688:	5f df       	rcall	.-322    	; 0x548 <pinMode.part.1>
_ZN9UartClass5beginEmj():
     68a:	0e 0d       	add	r16, r14
     68c:	1f 1d       	adc	r17, r15
     68e:	c0 0f       	add	r28, r16
     690:	d1 1f       	adc	r29, r17
     692:	61 e0       	ldi	r22, 0x01	; 1
     694:	8f 85       	ldd	r24, Y+15	; 0x0f
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:233
  pinMode(set->tx_pin, OUTPUT);
     696:	31 df       	rcall	.-414    	; 0x4fa <digitalWrite>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:31
     698:	8f 85       	ldd	r24, Y+15	; 0x0f
pinMode():
     69a:	8e 32       	cpi	r24, 0x2E	; 46
     69c:	10 f4       	brcc	.+4      	; 0x6a2 <UartClass::begin(unsigned long, unsigned int)+0xfe>
     69e:	61 e0       	ldi	r22, 0x01	; 1
     6a0:	53 df       	rcall	.-346    	; 0x548 <pinMode.part.1>
_ZN9UartClass5beginEmj():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:236

  // Restore SREG content
  SREG = oldSREG;
     6a2:	bf be       	out	0x3f, r11	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART.cpp:237
}
     6a4:	df 91       	pop	r29
     6a6:	cf 91       	pop	r28
     6a8:	1f 91       	pop	r17
     6aa:	0f 91       	pop	r16
     6ac:	ff 90       	pop	r15
     6ae:	ef 90       	pop	r14
     6b0:	df 90       	pop	r13
     6b2:	cf 90       	pop	r12
     6b4:	bf 90       	pop	r11
     6b6:	af 90       	pop	r10
     6b8:	08 95       	ret

000006ba <analogRead>:
analogRead():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:56
  }
}

int analogRead(uint8_t pin)
{
  pin = digitalPinToAnalogInput(pin);
     6ba:	81 31       	cpi	r24, 0x11	; 17
     6bc:	99 f0       	breq	.+38     	; 0x6e4 <analogRead+0x2a>
     6be:	84 31       	cpi	r24, 0x14	; 20
     6c0:	99 f0       	breq	.+38     	; 0x6e8 <analogRead+0x2e>
     6c2:	85 31       	cpi	r24, 0x15	; 21
     6c4:	99 f4       	brne	.+38     	; 0x6ec <analogRead+0x32>
     6c6:	85 e0       	ldi	r24, 0x05	; 5
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:63
    return NOT_A_PIN;

#if defined(ADC0)
  /* Reference should be already set up */
  /* Select channel */
  ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
     6c8:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x7f4606>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:66

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <__TEXT_REGION_LENGTH__+0x7f4608>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:69

  /* Wait for result ready */
  while (!(ADC0.INTFLAGS & ADC_RESRDY_bm))
     6d2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x7f460b>
     6d6:	80 ff       	sbrs	r24, 0
     6d8:	fc cf       	rjmp	.-8      	; 0x6d2 <analogRead+0x18>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:73
    ;

  /* Combine two bytes */
  return ADC0.RES;
     6da:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7f4610>
     6de:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7f4611>
     6e2:	08 95       	ret
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:56
  }
}

int analogRead(uint8_t pin)
{
  pin = digitalPinToAnalogInput(pin);
     6e4:	80 e0       	ldi	r24, 0x00	; 0
     6e6:	f0 cf       	rjmp	.-32     	; 0x6c8 <analogRead+0xe>
     6e8:	84 e0       	ldi	r24, 0x04	; 4
     6ea:	ee cf       	rjmp	.-36     	; 0x6c8 <analogRead+0xe>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:58
  if (pin > 15)
    return NOT_A_PIN;
     6ec:	8f ef       	ldi	r24, 0xFF	; 255
     6ee:	90 e0       	ldi	r25, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:78
  return ADC0.RES;

#else /* No ADC, return 0 */
  return 0;
#endif
}
     6f0:	08 95       	ret

000006f2 <port_interrupt_handler>:
port_interrupt_handler():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:112
    intFunc[interruptNum] = 0;
  }
}

static void port_interrupt_handler(uint8_t port)
{
     6f2:	ef 92       	push	r14
     6f4:	ff 92       	push	r15
     6f6:	0f 93       	push	r16
     6f8:	1f 93       	push	r17
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:113
  PORT_t *portStruct = portToPortStruct(port);
     6fe:	90 e2       	ldi	r25, 0x20	; 32
     700:	89 9f       	mul	r24, r25
     702:	e0 01       	movw	r28, r0
     704:	11 24       	eor	r1, r1
     706:	dc 5f       	subi	r29, 0xFC	; 252
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:115
  /* Copy flags */
  uint8_t int_flags = portStruct->INTFLAGS;
     708:	e9 84       	ldd	r14, Y+9	; 0x09
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:126
  {
    /* Check if flag raised */
    if (int_flags & bit_mask)
    {
      /* Get interrupt */
      uint8_t interrupt_num = port * 8 + bit_pos;
     70a:	08 2f       	mov	r16, r24
     70c:	00 0f       	add	r16, r16
     70e:	00 0f       	add	r16, r16
     710:	00 0f       	add	r16, r16
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:117
{
  PORT_t *portStruct = portToPortStruct(port);
  /* Copy flags */
  uint8_t int_flags = portStruct->INTFLAGS;

  uint8_t bit_pos = PIN0_bp, bit_mask = PIN0_bm;
     712:	ff 24       	eor	r15, r15
     714:	f3 94       	inc	r15
     716:	10 e0       	ldi	r17, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:123

  /* Iterate through flags */
  while (bit_pos <= PIN7_bp)
  {
    /* Check if flag raised */
    if (int_flags & bit_mask)
     718:	8e 2d       	mov	r24, r14
     71a:	8f 21       	and	r24, r15
     71c:	79 f0       	breq	.+30     	; 0x73c <port_interrupt_handler+0x4a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:129
    {
      /* Get interrupt */
      uint8_t interrupt_num = port * 8 + bit_pos;

      /* Check if function defined */
      if (intFunc[interrupt_num] != 0)
     71e:	e0 2f       	mov	r30, r16
     720:	e1 0f       	add	r30, r17
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	ee 0f       	add	r30, r30
     726:	ff 1f       	adc	r31, r31
     728:	ee 5e       	subi	r30, 0xEE	; 238
     72a:	f7 4d       	sbci	r31, 0xD7	; 215
     72c:	80 81       	ld	r24, Z
     72e:	91 81       	ldd	r25, Z+1	; 0x01
     730:	89 2b       	or	r24, r25
     732:	21 f0       	breq	.+8      	; 0x73c <port_interrupt_handler+0x4a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:132
      {
        /* Call function */
        intFunc[interrupt_num]();
     734:	01 90       	ld	r0, Z+
     736:	f0 81       	ld	r31, Z
     738:	e0 2d       	mov	r30, r0
     73a:	09 95       	icall
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:135
      }
    }
    bit_pos++;
     73c:	1f 5f       	subi	r17, 0xFF	; 255
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:136
    bit_mask = (bit_mask << 1);
     73e:	ff 0c       	add	r15, r15
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:120
  uint8_t int_flags = portStruct->INTFLAGS;

  uint8_t bit_pos = PIN0_bp, bit_mask = PIN0_bm;

  /* Iterate through flags */
  while (bit_pos <= PIN7_bp)
     740:	18 30       	cpi	r17, 0x08	; 8
     742:	51 f7       	brne	.-44     	; 0x718 <port_interrupt_handler+0x26>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:140
    bit_pos++;
    bit_mask = (bit_mask << 1);
  }

  /* Clear flags that have been handled */
  portStruct->INTFLAGS = int_flags;
     744:	e9 86       	std	Y+9, r14	; 0x09
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:141
}
     746:	df 91       	pop	r29
     748:	cf 91       	pop	r28
     74a:	1f 91       	pop	r17
     74c:	0f 91       	pop	r16
     74e:	ff 90       	pop	r15
     750:	ef 90       	pop	r14
     752:	08 95       	ret

00000754 <rocker1Int()>:
_Z10rocker1Intv():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:87
{
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer_millis)
  uint8_t status = SREG;
     754:	2f b7       	in	r18, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:88
  cli();
     756:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:90

  m = timer_millis;
     758:	80 91 0e 28 	lds	r24, 0x280E	; 0x80280e <timer_millis>
     75c:	90 91 0f 28 	lds	r25, 0x280F	; 0x80280f <timer_millis+0x1>
     760:	a0 91 10 28 	lds	r26, 0x2810	; 0x802810 <timer_millis+0x2>
     764:	b0 91 11 28 	lds	r27, 0x2811	; 0x802811 <timer_millis+0x3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:92

  SREG = status;
     768:	2f bf       	out	0x3f, r18	; 63
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:192

    // If the switch changed, due to noise or pressing:
    // if (reading != lastrockerState)
    {
        // reset the debouncing timer
        lastDebounceTime = millis();
     76a:	80 93 0a 28 	sts	0x280A, r24	; 0x80280a <lastDebounceTime>
     76e:	90 93 0b 28 	sts	0x280B, r25	; 0x80280b <lastDebounceTime+0x1>
     772:	a0 93 0c 28 	sts	0x280C, r26	; 0x80280c <lastDebounceTime+0x2>
     776:	b0 93 0d 28 	sts	0x280D, r27	; 0x80280d <lastDebounceTime+0x3>
millis():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:87
{
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer_millis)
  uint8_t status = SREG;
     77a:	2f b7       	in	r18, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:88
  cli();
     77c:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:90

  m = timer_millis;
     77e:	80 91 0e 28 	lds	r24, 0x280E	; 0x80280e <timer_millis>
     782:	90 91 0f 28 	lds	r25, 0x280F	; 0x80280f <timer_millis+0x1>
     786:	a0 91 10 28 	lds	r26, 0x2810	; 0x802810 <timer_millis+0x2>
     78a:	b0 91 11 28 	lds	r27, 0x2811	; 0x802811 <timer_millis+0x3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:92

  SREG = status;
     78e:	2f bf       	out	0x3f, r18	; 63
_Z10rocker1Intv():
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:195
    }

    if ((millis() - lastDebounceTime) > debounceDelay &&
     790:	40 91 0a 28 	lds	r20, 0x280A	; 0x80280a <lastDebounceTime>
     794:	50 91 0b 28 	lds	r21, 0x280B	; 0x80280b <lastDebounceTime+0x1>
     798:	60 91 0c 28 	lds	r22, 0x280C	; 0x80280c <lastDebounceTime+0x2>
     79c:	70 91 0d 28 	lds	r23, 0x280D	; 0x80280d <lastDebounceTime+0x3>
     7a0:	84 1b       	sub	r24, r20
     7a2:	95 0b       	sbc	r25, r21
     7a4:	a6 0b       	sbc	r26, r22
     7a6:	b7 0b       	sbc	r27, r23
     7a8:	85 3f       	cpi	r24, 0xF5	; 245
     7aa:	91 40       	sbci	r25, 0x01	; 1
     7ac:	a1 05       	cpc	r26, r1
     7ae:	b1 05       	cpc	r27, r1
     7b0:	30 f1       	brcs	.+76     	; 0x7fe <rocker1Int()+0xaa>
millis():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:87
{
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer_millis)
  uint8_t status = SREG;
     7b2:	2f b7       	in	r18, 0x3f	; 63
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:88
  cli();
     7b4:	f8 94       	cli
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:90

  m = timer_millis;
     7b6:	80 91 0e 28 	lds	r24, 0x280E	; 0x80280e <timer_millis>
     7ba:	90 91 0f 28 	lds	r25, 0x280F	; 0x80280f <timer_millis+0x1>
     7be:	a0 91 10 28 	lds	r26, 0x2810	; 0x802810 <timer_millis+0x2>
     7c2:	b0 91 11 28 	lds	r27, 0x2811	; 0x802811 <timer_millis+0x3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:92

  SREG = status;
     7c6:	2f bf       	out	0x3f, r18	; 63
_Z10rocker1Intv():
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:196
        (millis() - lastDebounceTime) < longdebounceDelay) {
     7c8:	40 91 0a 28 	lds	r20, 0x280A	; 0x80280a <lastDebounceTime>
     7cc:	50 91 0b 28 	lds	r21, 0x280B	; 0x80280b <lastDebounceTime+0x1>
     7d0:	60 91 0c 28 	lds	r22, 0x280C	; 0x80280c <lastDebounceTime+0x2>
     7d4:	70 91 0d 28 	lds	r23, 0x280D	; 0x80280d <lastDebounceTime+0x3>
     7d8:	84 1b       	sub	r24, r20
     7da:	95 0b       	sbc	r25, r21
     7dc:	a6 0b       	sbc	r26, r22
     7de:	b7 0b       	sbc	r27, r23
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:195
    {
        // reset the debouncing timer
        lastDebounceTime = millis();
    }

    if ((millis() - lastDebounceTime) > debounceDelay &&
     7e0:	88 3e       	cpi	r24, 0xE8	; 232
     7e2:	93 40       	sbci	r25, 0x03	; 3
     7e4:	a1 05       	cpc	r26, r1
     7e6:	b1 05       	cpc	r27, r1
     7e8:	50 f4       	brcc	.+20     	; 0x7fe <rocker1Int()+0xaa>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:200
        (millis() - lastDebounceTime) < longdebounceDelay) {
        // whatever the reading is at, it's been there for longer than the debounce
        // delay, so take it as the actual current state:

        rockerval = rockerval + shortrockerval;
     7ea:	80 91 75 28 	lds	r24, 0x2875	; 0x802875 <rockerval>
     7ee:	90 91 76 28 	lds	r25, 0x2876	; 0x802876 <rockerval+0x1>
     7f2:	c2 96       	adiw	r24, 0x32	; 50
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:204

    }
    else {
        rockerval = rockerval + longrockerval;
     7f4:	80 93 75 28 	sts	0x2875, r24	; 0x802875 <rockerval>
     7f8:	90 93 76 28 	sts	0x2876, r25	; 0x802876 <rockerval+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:209
    }

    //  results for things work in most need go through vespa again this code save the reading. Next time through the loop, it'll be the lastButtonState:
      // lastrockerState = reading;
}
     7fc:	08 95       	ret
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:204

        rockerval = rockerval + shortrockerval;

    }
    else {
        rockerval = rockerval + longrockerval;
     7fe:	80 91 75 28 	lds	r24, 0x2875	; 0x802875 <rockerval>
     802:	90 91 76 28 	lds	r25, 0x2876	; 0x802876 <rockerval+0x1>
     806:	8c 59       	subi	r24, 0x9C	; 156
     808:	9f 4f       	sbci	r25, 0xFF	; 255
     80a:	f4 cf       	rjmp	.-24     	; 0x7f4 <rocker1Int()+0xa0>

0000080c <EERef::operator*() const>:
_ZNK5EERefdeEv():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:52
{
  EERef(const int index)
      : index(index) {}

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
     80c:	fc 01       	movw	r30, r24
     80e:	80 81       	ld	r24, Z
     810:	91 81       	ldd	r25, Z+1	; 0x01
     812:	fc 01       	movw	r30, r24
     814:	ff 27       	eor	r31, r31
     816:	90 fd       	sbrc	r25, 0
     818:	06 c0       	rjmp	.+12     	; 0x826 <EERef::operator*() const+0x1a>
     81a:	80 e0       	ldi	r24, 0x00	; 0
     81c:	94 e1       	ldi	r25, 0x14	; 20
     81e:	e8 2b       	or	r30, r24
     820:	f9 2b       	or	r31, r25
     822:	80 81       	ld	r24, Z
     824:	08 95       	ret
     826:	80 e0       	ldi	r24, 0x00	; 0
     828:	93 e1       	ldi	r25, 0x13	; 19
     82a:	f9 cf       	rjmp	.-14     	; 0x81e <EERef::operator*() const+0x12>

0000082c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>:
_ZN11EEPROMClass3getIjEERT_iS2_.isra.6():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:141
  EEPtr end() { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
  uint16_t length() { return EEPROM_SIZE; }

  //Functionality to 'get' and 'put' objects to and from EEPROM.
  template <typename T>
  T &get(int idx, T &t)
     82c:	ef 92       	push	r14
     82e:	ff 92       	push	r15
     830:	0f 93       	push	r16
     832:	1f 93       	push	r17
     834:	cf 93       	push	r28
     836:	df 93       	push	r29
     838:	00 d0       	rcall	.+0      	; 0x83a <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]+0xe>
     83a:	cd b7       	in	r28, 0x3d	; 61
     83c:	de b7       	in	r29, 0x3e	; 62
     83e:	8c 01       	movw	r16, r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
     840:	7b 01       	movw	r14, r22
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53
  EERef(const int index)
      : index(index) {}

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
     842:	89 83       	std	Y+1, r24	; 0x01
     844:	9a 83       	std	Y+2, r25	; 0x02
_ZNK5EERefcvhEv():
     846:	ce 01       	movw	r24, r28
     848:	01 96       	adiw	r24, 0x01	; 1
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  template <typename T>
  T &get(int idx, T &t)
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
     84a:	e0 df       	rcall	.-64     	; 0x80c <EERef::operator*() const>
_ZN11EEPROMClass3getIjEERT_iS2_.isra.6():
     84c:	f7 01       	movw	r30, r14
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:111
  //Iterator functionality.
  bool operator!=(const EEPtr &ptr) { return index != ptr.index; }
  EERef operator*() { return index; }

  /** Prefix & Postfix increment/decrement **/
  EEPtr &operator++() { return ++index, *this; }
     84e:	80 83       	st	Z, r24
_ZN5EEPtrppEv():
     850:	0f 5f       	subi	r16, 0xFF	; 255
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  template <typename T>
  T &get(int idx, T &t)
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
     852:	1f 4f       	sbci	r17, 0xFF	; 255
_ZN11EEPROMClass3getIjEERT_iS2_.isra.6():
     854:	09 83       	std	Y+1, r16	; 0x01
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53
  EERef(const int index)
      : index(index) {}

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
     856:	1a 83       	std	Y+2, r17	; 0x02
_ZNK5EERefcvhEv():
     858:	ce 01       	movw	r24, r28
     85a:	01 96       	adiw	r24, 0x01	; 1
     85c:	d7 df       	rcall	.-82     	; 0x80c <EERef::operator*() const>
_ZN11EEPROMClass3getIjEERT_iS2_.isra.6():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  template <typename T>
  T &get(int idx, T &t)
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
     85e:	f7 01       	movw	r30, r14
     860:	81 83       	std	Z+1, r24	; 0x01
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:147
    return t;
  }
     862:	c7 01       	movw	r24, r14
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	ff 90       	pop	r15
     872:	ef 90       	pop	r14
     874:	08 95       	ret

00000876 <nvm_write_byte(unsigned int, unsigned char)>:
_ZL14nvm_write_bytejh():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:37

#define nvm_read_byte(idx) *(uint8_t *)((idx & 0xFF) | ((idx & 0x100) ? USER_SIGNATURES_START : EEPROM_START))

static void nvm_write_byte(uint16_t idx, uint8_t dat)
{
  *(uint8_t *)((idx & 0xFF) | ((idx & 0x100) ? USER_SIGNATURES_START : EEPROM_START)) = dat;
     876:	fc 01       	movw	r30, r24
     878:	ff 27       	eor	r31, r31
     87a:	90 fd       	sbrc	r25, 0
     87c:	12 c0       	rjmp	.+36     	; 0x8a2 <nvm_write_byte(unsigned int, unsigned char)+0x2c>
     87e:	80 e0       	ldi	r24, 0x00	; 0
     880:	94 e1       	ldi	r25, 0x14	; 20
     882:	e8 2b       	or	r30, r24
     884:	f9 2b       	or	r31, r25
     886:	60 83       	st	Z, r22
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:38
  uint8_t oldSREG = SREG;
     888:	8f b7       	in	r24, 0x3f	; 63
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:39
  cli();
     88a:	f8 94       	cli
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:40
  _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
     88c:	9d e9       	ldi	r25, 0x9D	; 157
     88e:	23 e0       	ldi	r18, 0x03	; 3
     890:	94 bf       	out	0x34, r25	; 52
     892:	20 93 00 10 	sts	0x1000, r18	; 0x801000 <__TEXT_REGION_LENGTH__+0x7f5000>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:41
  SREG = oldSREG;
     896:	8f bf       	out	0x3f, r24	; 63
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:42
  while (NVMCTRL.STATUS & NVMCTRL_EEBUSY_bm)
     898:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x7f5002>
     89c:	81 fd       	sbrc	r24, 1
     89e:	fc cf       	rjmp	.-8      	; 0x898 <nvm_write_byte(unsigned int, unsigned char)+0x22>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:44
    ;
}
     8a0:	08 95       	ret
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:37

#define nvm_read_byte(idx) *(uint8_t *)((idx & 0xFF) | ((idx & 0x100) ? USER_SIGNATURES_START : EEPROM_START))

static void nvm_write_byte(uint16_t idx, uint8_t dat)
{
  *(uint8_t *)((idx & 0xFF) | ((idx & 0x100) ? USER_SIGNATURES_START : EEPROM_START)) = dat;
     8a2:	80 e0       	ldi	r24, 0x00	; 0
     8a4:	93 e1       	ldi	r25, 0x13	; 19
     8a6:	ed cf       	rjmp	.-38     	; 0x882 <nvm_write_byte(unsigned int, unsigned char)+0xc>

000008a8 <EEPROMClass::update(int, unsigned char) [clone .isra.3]>:
_ZN11EEPROMClass6updateEih.isra.3():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:132
{
  //Basic user access methods.
  EERef operator[](const int idx) { return idx; }
  uint8_t read(int idx) { return EERef(idx); }
  void write(int idx, uint8_t val) { (EERef(idx)) = val; }
  void update(int idx, uint8_t val) { EERef(idx).update(val); }
     8a8:	ff 92       	push	r15
     8aa:	0f 93       	push	r16
     8ac:	1f 93       	push	r17
     8ae:	cf 93       	push	r28
     8b0:	df 93       	push	r29
     8b2:	00 d0       	rcall	.+0      	; 0x8b4 <EEPROMClass::update(int, unsigned char) [clone .isra.3]+0xc>
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	8c 01       	movw	r16, r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:49
}

struct EERef
{
  EERef(const int index)
      : index(index) {}
     8ba:	f6 2e       	mov	r15, r22
_ZN5EERefC2Ei():
     8bc:	89 83       	std	Y+1, r24	; 0x01
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
     8be:	9a 83       	std	Y+2, r25	; 0x02
_ZNK5EERefcvhEv():
     8c0:	ce 01       	movw	r24, r28
     8c2:	01 96       	adiw	r24, 0x01	; 1
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:69
  EERef &operator&=(uint8_t in) { return *this = **this & in; }
  EERef &operator|=(uint8_t in) { return *this = **this | in; }
  EERef &operator<<=(uint8_t in) { return *this = **this << in; }
  EERef &operator>>=(uint8_t in) { return *this = **this >> in; }

  EERef &update(uint8_t in) { return in != *this ? *this = in : *this; }
     8c4:	a3 df       	rcall	.-186    	; 0x80c <EERef::operator*() const>
update():
     8c6:	f8 16       	cp	r15, r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:57
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }

  //Assignment/write members.
  EERef &operator=(const EERef &ref) { return *this = *ref; }
  EERef &operator=(uint8_t in) { return nvm_write_byte(index, in), *this; }
     8c8:	51 f0       	breq	.+20     	; 0x8de <EEPROMClass::update(int, unsigned char) [clone .isra.3]+0x36>
operator=():
     8ca:	6f 2d       	mov	r22, r15
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:132
{
  //Basic user access methods.
  EERef operator[](const int idx) { return idx; }
  uint8_t read(int idx) { return EERef(idx); }
  void write(int idx, uint8_t val) { (EERef(idx)) = val; }
  void update(int idx, uint8_t val) { EERef(idx).update(val); }
     8cc:	c8 01       	movw	r24, r16
_ZN11EEPROMClass6updateEih.isra.3():
     8ce:	0f 90       	pop	r0
     8d0:	0f 90       	pop	r0
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	1f 91       	pop	r17
     8d8:	0f 91       	pop	r16
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:57
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }

  //Assignment/write members.
  EERef &operator=(const EERef &ref) { return *this = *ref; }
  EERef &operator=(uint8_t in) { return nvm_write_byte(index, in), *this; }
     8da:	ff 90       	pop	r15
operator=():
     8dc:	cc cf       	rjmp	.-104    	; 0x876 <nvm_write_byte(unsigned int, unsigned char)>
_ZN11EEPROMClass6updateEih.isra.3():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:132
{
  //Basic user access methods.
  EERef operator[](const int idx) { return idx; }
  uint8_t read(int idx) { return EERef(idx); }
  void write(int idx, uint8_t val) { (EERef(idx)) = val; }
  void update(int idx, uint8_t val) { EERef(idx).update(val); }
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	1f 91       	pop	r17
     8e8:	0f 91       	pop	r16
     8ea:	ff 90       	pop	r15
     8ec:	08 95       	ret

000008ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>:
_ZN11EEPROMClass3putIjEERKT_iS3_.isra.5():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:150
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
    return t;
  }

  template <typename T>
  const T &put(int idx, const T &t)
     8ee:	8f 92       	push	r8
     8f0:	9f 92       	push	r9
     8f2:	bf 92       	push	r11
     8f4:	cf 92       	push	r12
     8f6:	df 92       	push	r13
     8f8:	ef 92       	push	r14
     8fa:	ff 92       	push	r15
     8fc:	0f 93       	push	r16
     8fe:	1f 93       	push	r17
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	00 d0       	rcall	.+0      	; 0x906 <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]+0x18>
     906:	cd b7       	in	r28, 0x3d	; 61
     908:	de b7       	in	r29, 0x3e	; 62
     90a:	8c 01       	movw	r16, r24
     90c:	6b 01       	movw	r12, r22
     90e:	7b 01       	movw	r14, r22
     910:	4c 01       	movw	r8, r24
     912:	82 e0       	ldi	r24, 0x02	; 2
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:154
  {
    EEPtr e = idx;
    const uint8_t *ptr = (const uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) (*e).update(*ptr++);
     914:	88 0e       	add	r8, r24
     916:	91 1c       	adc	r9, r1
     918:	09 83       	std	Y+1, r16	; 0x01
     91a:	1a 83       	std	Y+2, r17	; 0x02
     91c:	f7 01       	movw	r30, r14
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53
  EERef(const int index)
      : index(index) {}

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
     91e:	b1 90       	ld	r11, Z+
     920:	7f 01       	movw	r14, r30
_ZNK5EERefcvhEv():
     922:	ce 01       	movw	r24, r28
     924:	01 96       	adiw	r24, 0x01	; 1
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:69
  EERef &operator&=(uint8_t in) { return *this = **this & in; }
  EERef &operator|=(uint8_t in) { return *this = **this | in; }
  EERef &operator<<=(uint8_t in) { return *this = **this << in; }
  EERef &operator>>=(uint8_t in) { return *this = **this >> in; }

  EERef &update(uint8_t in) { return in != *this ? *this = in : *this; }
     926:	72 df       	rcall	.-284    	; 0x80c <EERef::operator*() const>
update():
     928:	b8 16       	cp	r11, r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:57
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }

  //Assignment/write members.
  EERef &operator=(const EERef &ref) { return *this = *ref; }
  EERef &operator=(uint8_t in) { return nvm_write_byte(index, in), *this; }
     92a:	19 f0       	breq	.+6      	; 0x932 <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]+0x44>
operator=():
     92c:	6b 2d       	mov	r22, r11
     92e:	c8 01       	movw	r24, r16
     930:	a2 df       	rcall	.-188    	; 0x876 <nvm_write_byte(unsigned int, unsigned char)>
_ZN5EEPtrppEv():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:111
  //Iterator functionality.
  bool operator!=(const EEPtr &ptr) { return index != ptr.index; }
  EERef operator*() { return index; }

  /** Prefix & Postfix increment/decrement **/
  EEPtr &operator++() { return ++index, *this; }
     932:	0f 5f       	subi	r16, 0xFF	; 255
     934:	1f 4f       	sbci	r17, 0xFF	; 255
_ZN11EEPROMClass3putIjEERKT_iS3_.isra.5():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:154
  template <typename T>
  const T &put(int idx, const T &t)
  {
    EEPtr e = idx;
    const uint8_t *ptr = (const uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) (*e).update(*ptr++);
     936:	08 15       	cp	r16, r8
     938:	19 05       	cpc	r17, r9
     93a:	71 f7       	brne	.-36     	; 0x918 <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]+0x2a>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:156
    return t;
  }
     93c:	c6 01       	movw	r24, r12
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	df 91       	pop	r29
     944:	cf 91       	pop	r28
     946:	1f 91       	pop	r17
     948:	0f 91       	pop	r16
     94a:	ff 90       	pop	r15
     94c:	ef 90       	pop	r14
     94e:	df 90       	pop	r13
     950:	cf 90       	pop	r12
     952:	bf 90       	pop	r11
     954:	9f 90       	pop	r9
     956:	8f 90       	pop	r8
     958:	08 95       	ret

0000095a <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART.h:160

  public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t hwserial_rx_pin, uint8_t hwserial_tx_pin, uint8_t hwserial_rx_pin_swap, uint8_t hwserial_tx_pin_swap, uint8_t dre_vect_num, uint8_t uart_mux, uint8_t uart_mux_swap);
    bool pins(uint8_t tx, uint8_t rx);
    bool swap(uint8_t state = 1);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     95a:	dc 01       	movw	r26, r24
     95c:	ed 91       	ld	r30, X+
     95e:	fc 91       	ld	r31, X
     960:	04 88       	ldd	r0, Z+20	; 0x14
     962:	f5 89       	ldd	r31, Z+21	; 0x15
     964:	e0 2d       	mov	r30, r0
     966:	23 e0       	ldi	r18, 0x03	; 3
     968:	30 e0       	ldi	r19, 0x00	; 0
     96a:	09 94       	ijmp

0000096c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]>:
_ZN5Print11printNumberEmh.constprop.19():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:245
  return vfprintf_P(&f, (const char *)format, ap);
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
     96c:	8f 92       	push	r8
     96e:	9f 92       	push	r9
     970:	af 92       	push	r10
     972:	bf 92       	push	r11
     974:	0f 93       	push	r16
     976:	1f 93       	push	r17
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	a1 97       	sbiw	r28, 0x21	; 33
     982:	cd bf       	out	0x3d, r28	; 61
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:250
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     984:	de bf       	out	0x3e, r29	; 62
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:253

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     986:	19 a2       	std	Y+33, r1	; 0x21
     988:	42 30       	cpi	r20, 0x02	; 2
     98a:	08 f4       	brcc	.+2      	; 0x98e <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x22>
     98c:	4a e0       	ldi	r20, 0x0A	; 10
     98e:	8e 01       	movw	r16, r28
     990:	0f 5d       	subi	r16, 0xDF	; 223
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:257

  do
  {
    char c = n % base;
     992:	1f 4f       	sbci	r17, 0xFF	; 255
     994:	84 2e       	mov	r8, r20
     996:	91 2c       	mov	r9, r1
     998:	b1 2c       	mov	r11, r1
     99a:	a1 2c       	mov	r10, r1
     99c:	a5 01       	movw	r20, r10
     99e:	94 01       	movw	r18, r8
     9a0:	79 d6       	rcall	.+3314   	; 0x1694 <__udivmodsi4>
     9a2:	e6 2f       	mov	r30, r22
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:258
    n /= base;
     9a4:	b9 01       	movw	r22, r18
     9a6:	ca 01       	movw	r24, r20
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:260

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     9a8:	ea 30       	cpi	r30, 0x0A	; 10
     9aa:	24 f5       	brge	.+72     	; 0x9f4 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x88>
     9ac:	e0 5d       	subi	r30, 0xD0	; 208
     9ae:	d8 01       	movw	r26, r16
     9b0:	ee 93       	st	-X, r30
     9b2:	8d 01       	movw	r16, r26
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:261
  } while (n);
     9b4:	23 2b       	or	r18, r19
     9b6:	24 2b       	or	r18, r20
     9b8:	25 2b       	or	r18, r21
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles\api/Print.h:48
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     9ba:	81 f7       	brne	.-32     	; 0x99c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x30>
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	80 e0       	ldi	r24, 0x00	; 0
write():
     9c0:	10 97       	sbiw	r26, 0x00	; 0
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles\api/Print.h:49
      return write((const uint8_t *)str, strlen(str));
     9c2:	61 f0       	breq	.+24     	; 0x9dc <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x70>
     9c4:	fd 01       	movw	r30, r26
     9c6:	01 90       	ld	r0, Z+
     9c8:	00 20       	and	r0, r0
     9ca:	e9 f7       	brne	.-6      	; 0x9c6 <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x5a>
     9cc:	31 97       	sbiw	r30, 0x01	; 1
     9ce:	af 01       	movw	r20, r30
     9d0:	4a 1b       	sub	r20, r26
     9d2:	5b 0b       	sbc	r21, r27
     9d4:	bd 01       	movw	r22, r26
     9d6:	8b e7       	ldi	r24, 0x7B	; 123
     9d8:	98 e2       	ldi	r25, 0x28	; 40
     9da:	fd dc       	rcall	.-1542   	; 0x3d6 <Print::write(unsigned char const*, unsigned int)>
_ZN5Print11printNumberEmh.constprop.19():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:264

  return write(str);
}
     9dc:	a1 96       	adiw	r28, 0x21	; 33
     9de:	cd bf       	out	0x3d, r28	; 61
     9e0:	de bf       	out	0x3e, r29	; 62
     9e2:	df 91       	pop	r29
     9e4:	cf 91       	pop	r28
     9e6:	1f 91       	pop	r17
     9e8:	0f 91       	pop	r16
     9ea:	bf 90       	pop	r11
     9ec:	af 90       	pop	r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:260
  do
  {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     9ee:	9f 90       	pop	r9
     9f0:	8f 90       	pop	r8
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles\api/Print.h:49
     9f2:	08 95       	ret
     9f4:	e9 5c       	subi	r30, 0xC9	; 201
     9f6:	db cf       	rjmp	.-74     	; 0x9ae <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]+0x42>

000009f8 <Print::println() [clone .constprop.21]>:
_ZN5Print7printlnEv.constprop.21():
     9f8:	42 e0       	ldi	r20, 0x02	; 2
     9fa:	50 e0       	ldi	r21, 0x00	; 0
     9fc:	62 e7       	ldi	r22, 0x72	; 114
     9fe:	78 e5       	ldi	r23, 0x58	; 88
     a00:	8b e7       	ldi	r24, 0x7B	; 123
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:179
  size_t n = print(num, base);
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base)
     a02:	98 e2       	ldi	r25, 0x28	; 40
     a04:	e8 cc       	rjmp	.-1584   	; 0x3d6 <Print::write(unsigned char const*, unsigned int)>

00000a06 <Print::println(unsigned int, int) [clone .constprop.15]>:
_ZN5Print7printlnEji.constprop.15():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:89
  return print((long)n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long)n, base);
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
print():
     a0a:	bc 01       	movw	r22, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:119
size_t Print::print(unsigned long n, int base)
{
  if (base == 0)
    return write(n);
  else
    return printNumber(n, base);
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	4a e0       	ldi	r20, 0x0A	; 10
     a12:	ac df       	rcall	.-168    	; 0x96c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:182
}

size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
     a14:	ec 01       	movw	r28, r24
_ZN5Print7printlnEji.constprop.15():
     a16:	f0 df       	rcall	.-32     	; 0x9f8 <Print::println() [clone .constprop.21]>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:184
  return n;
}
     a18:	8c 0f       	add	r24, r28
     a1a:	9d 1f       	adc	r25, r29
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:50
#error "Don't know what the Data Received interrupt vector is called for Serial"
#endif

#if defined(HWSERIAL0_DRE_VECTOR)
ISR(HWSERIAL0_DRE_VECTOR)
{
     a20:	08 95       	ret

00000a22 <__vector_38>:
__vector_38():
     a22:	1f 92       	push	r1
     a24:	0f 92       	push	r0
     a26:	0f b6       	in	r0, 0x3f	; 63
     a28:	0f 92       	push	r0
     a2a:	11 24       	eor	r1, r1
     a2c:	2f 93       	push	r18
     a2e:	3f 93       	push	r19
     a30:	4f 93       	push	r20
     a32:	5f 93       	push	r21
     a34:	6f 93       	push	r22
     a36:	7f 93       	push	r23
     a38:	8f 93       	push	r24
     a3a:	9f 93       	push	r25
     a3c:	af 93       	push	r26
     a3e:	bf 93       	push	r27
     a40:	ef 93       	push	r30
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:51
  Serial._tx_data_empty_irq();
     a42:	ff 93       	push	r31
     a44:	8b e7       	ldi	r24, 0x7B	; 123
     a46:	98 e2       	ldi	r25, 0x28	; 40
     a48:	d8 db       	rcall	.-2128   	; 0x1fa <UartClass::_tx_data_empty_irq()>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:52
}
     a4a:	ff 91       	pop	r31
     a4c:	ef 91       	pop	r30
     a4e:	bf 91       	pop	r27
     a50:	af 91       	pop	r26
     a52:	9f 91       	pop	r25
     a54:	8f 91       	pop	r24
     a56:	7f 91       	pop	r23
     a58:	6f 91       	pop	r22
     a5a:	5f 91       	pop	r21
     a5c:	4f 91       	pop	r20
     a5e:	3f 91       	pop	r19
     a60:	2f 91       	pop	r18
     a62:	0f 90       	pop	r0
     a64:	0f be       	out	0x3f, r0	; 63
     a66:	0f 90       	pop	r0
     a68:	1f 90       	pop	r1
     a6a:	18 95       	reti

00000a6c <__vector_37>:
__vector_37():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:41

#if defined(HAVE_HWSERIAL0)

#if defined(HWSERIAL0_RXC_VECTOR)
ISR(HWSERIAL0_RXC_VECTOR)
{
     a6c:	1f 92       	push	r1
     a6e:	0f 92       	push	r0
     a70:	0f b6       	in	r0, 0x3f	; 63
     a72:	0f 92       	push	r0
     a74:	11 24       	eor	r1, r1
     a76:	2f 93       	push	r18
     a78:	8f 93       	push	r24
     a7a:	9f 93       	push	r25
     a7c:	ef 93       	push	r30
     a7e:	ff 93       	push	r31
_rx_complete_irq():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:59
// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_rx_complete_irq(void)
{
  //if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  if (!(((*_hwserial_module).RXDATAH) & USART_PERR_bm)) {
     a80:	e0 91 87 28 	lds	r30, 0x2887	; 0x802887 <Serial+0xc>
     a84:	f0 91 88 28 	lds	r31, 0x2888	; 0x802888 <Serial+0xd>
     a88:	81 81       	ldd	r24, Z+1	; 0x01
     a8a:	81 fd       	sbrc	r24, 1
     a8c:	1b c0       	rjmp	.+54     	; 0xac4 <__vector_37+0x58>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:62
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = (*_hwserial_module).RXDATAL;
     a8e:	90 81       	ld	r25, Z
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:63
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     a90:	80 91 91 28 	lds	r24, 0x2891	; 0x802891 <Serial+0x16>
     a94:	8f 5f       	subi	r24, 0xFF	; 255
     a96:	8f 73       	andi	r24, 0x3F	; 63
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:69

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail)
     a98:	20 91 92 28 	lds	r18, 0x2892	; 0x802892 <Serial+0x17>
     a9c:	82 17       	cp	r24, r18
     a9e:	41 f0       	breq	.+16     	; 0xab0 <__vector_37+0x44>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:71
    {
      _rx_buffer[_rx_buffer_head] = c;
     aa0:	e0 91 91 28 	lds	r30, 0x2891	; 0x802891 <Serial+0x16>
     aa4:	f0 e0       	ldi	r31, 0x00	; 0
     aa6:	e5 58       	subi	r30, 0x85	; 133
     aa8:	f7 4d       	sbci	r31, 0xD7	; 215
     aaa:	95 8f       	std	Z+29, r25	; 0x1d
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:72
      _rx_buffer_head = i;
     aac:	80 93 91 28 	sts	0x2891, r24	; 0x802891 <Serial+0x16>
__vector_37():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/UART0.cpp:43
  Serial._rx_complete_irq();
}
     ab0:	ff 91       	pop	r31
     ab2:	ef 91       	pop	r30
     ab4:	9f 91       	pop	r25
     ab6:	8f 91       	pop	r24
     ab8:	2f 91       	pop	r18
     aba:	0f 90       	pop	r0
     abc:	0f be       	out	0x3f, r0	; 63
     abe:	0f 90       	pop	r0
     ac0:	1f 90       	pop	r1
     ac2:	18 95       	reti
_rx_complete_irq():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\cores\corex-corefiles/UART_private.h:78
    }
  } 
  else
  {
    // Parity error, read byte but discard it
    (*_hwserial_module).RXDATAL;
     ac4:	80 81       	ld	r24, Z
     ac6:	f4 cf       	rjmp	.-24     	; 0xab0 <__vector_37+0x44>

00000ac8 <__vector_36>:
__vector_36():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:74
#elif defined(MILLIS_USE_TIMERB2)
ISR(TCB2_INT_vect)
#else // fallback or defined(MILLIS_USE_TIMERB3)
ISR(TCB3_INT_vect)
#endif
{
     ac8:	1f 92       	push	r1
     aca:	0f 92       	push	r0
     acc:	0f b6       	in	r0, 0x3f	; 63
     ace:	0f 92       	push	r0
     ad0:	11 24       	eor	r1, r1
     ad2:	8f 93       	push	r24
     ad4:	9f 93       	push	r25
     ad6:	af 93       	push	r26
     ad8:	bf 93       	push	r27
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:75
  timer_millis++;
     ada:	80 91 0e 28 	lds	r24, 0x280E	; 0x80280e <timer_millis>
     ade:	90 91 0f 28 	lds	r25, 0x280F	; 0x80280f <timer_millis+0x1>
     ae2:	a0 91 10 28 	lds	r26, 0x2810	; 0x802810 <timer_millis+0x2>
     ae6:	b0 91 11 28 	lds	r27, 0x2811	; 0x802811 <timer_millis+0x3>
     aea:	01 96       	adiw	r24, 0x01	; 1
     aec:	a1 1d       	adc	r26, r1
     aee:	b1 1d       	adc	r27, r1
     af0:	80 93 0e 28 	sts	0x280E, r24	; 0x80280e <timer_millis>
     af4:	90 93 0f 28 	sts	0x280F, r25	; 0x80280f <timer_millis+0x1>
     af8:	a0 93 10 28 	sts	0x2810, r26	; 0x802810 <timer_millis+0x2>
     afc:	b0 93 11 28 	sts	0x2811, r27	; 0x802811 <timer_millis+0x3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:78

  /* Clear flag */
  _timer->INTFLAGS = TCB_CAPT_bm;
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	80 93 b6 0a 	sts	0x0AB6, r24	; 0x800ab6 <__TEXT_REGION_LENGTH__+0x7f4ab6>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:79
}
     b06:	bf 91       	pop	r27
     b08:	af 91       	pop	r26
     b0a:	9f 91       	pop	r25
     b0c:	8f 91       	pop	r24
     b0e:	0f 90       	pop	r0
     b10:	0f be       	out	0x3f, r0	; 63
     b12:	0f 90       	pop	r0
     b14:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:154
IMPLEMENT_ISR(PORTA_PORT_vect, PA)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
IMPLEMENT_ISR(PORTC_PORT_vect, PC)
IMPLEMENT_ISR(PORTD_PORT_vect, PD)
IMPLEMENT_ISR(PORTE_PORT_vect, PE)
IMPLEMENT_ISR(PORTF_PORT_vect, PF)
     b16:	18 95       	reti

00000b18 <__vector_29>:
__vector_29():
     b18:	1f 92       	push	r1
     b1a:	0f 92       	push	r0
     b1c:	0f b6       	in	r0, 0x3f	; 63
     b1e:	0f 92       	push	r0
     b20:	11 24       	eor	r1, r1
     b22:	2f 93       	push	r18
     b24:	3f 93       	push	r19
     b26:	4f 93       	push	r20
     b28:	5f 93       	push	r21
     b2a:	6f 93       	push	r22
     b2c:	7f 93       	push	r23
     b2e:	8f 93       	push	r24
     b30:	9f 93       	push	r25
     b32:	af 93       	push	r26
     b34:	bf 93       	push	r27
     b36:	ef 93       	push	r30
     b38:	ff 93       	push	r31
     b3a:	85 e0       	ldi	r24, 0x05	; 5
     b3c:	da dd       	rcall	.-1100   	; 0x6f2 <port_interrupt_handler>
     b3e:	ff 91       	pop	r31
     b40:	ef 91       	pop	r30
     b42:	bf 91       	pop	r27
     b44:	af 91       	pop	r26
     b46:	9f 91       	pop	r25
     b48:	8f 91       	pop	r24
     b4a:	7f 91       	pop	r23
     b4c:	6f 91       	pop	r22
     b4e:	5f 91       	pop	r21
     b50:	4f 91       	pop	r20
     b52:	3f 91       	pop	r19
     b54:	2f 91       	pop	r18
     b56:	0f 90       	pop	r0
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	0f 90       	pop	r0
     b5c:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:153

IMPLEMENT_ISR(PORTA_PORT_vect, PA)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
IMPLEMENT_ISR(PORTC_PORT_vect, PC)
IMPLEMENT_ISR(PORTD_PORT_vect, PD)
IMPLEMENT_ISR(PORTE_PORT_vect, PE)
     b5e:	18 95       	reti

00000b60 <__vector_35>:
__vector_35():
     b60:	1f 92       	push	r1
     b62:	0f 92       	push	r0
     b64:	0f b6       	in	r0, 0x3f	; 63
     b66:	0f 92       	push	r0
     b68:	11 24       	eor	r1, r1
     b6a:	2f 93       	push	r18
     b6c:	3f 93       	push	r19
     b6e:	4f 93       	push	r20
     b70:	5f 93       	push	r21
     b72:	6f 93       	push	r22
     b74:	7f 93       	push	r23
     b76:	8f 93       	push	r24
     b78:	9f 93       	push	r25
     b7a:	af 93       	push	r26
     b7c:	bf 93       	push	r27
     b7e:	ef 93       	push	r30
     b80:	ff 93       	push	r31
     b82:	84 e0       	ldi	r24, 0x04	; 4
     b84:	b6 dd       	rcall	.-1172   	; 0x6f2 <port_interrupt_handler>
     b86:	ff 91       	pop	r31
     b88:	ef 91       	pop	r30
     b8a:	bf 91       	pop	r27
     b8c:	af 91       	pop	r26
     b8e:	9f 91       	pop	r25
     b90:	8f 91       	pop	r24
     b92:	7f 91       	pop	r23
     b94:	6f 91       	pop	r22
     b96:	5f 91       	pop	r21
     b98:	4f 91       	pop	r20
     b9a:	3f 91       	pop	r19
     b9c:	2f 91       	pop	r18
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	0f 90       	pop	r0
     ba4:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:152
  }

IMPLEMENT_ISR(PORTA_PORT_vect, PA)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
IMPLEMENT_ISR(PORTC_PORT_vect, PC)
IMPLEMENT_ISR(PORTD_PORT_vect, PD)
     ba6:	18 95       	reti

00000ba8 <__vector_20>:
__vector_20():
     ba8:	1f 92       	push	r1
     baa:	0f 92       	push	r0
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	0f 92       	push	r0
     bb0:	11 24       	eor	r1, r1
     bb2:	2f 93       	push	r18
     bb4:	3f 93       	push	r19
     bb6:	4f 93       	push	r20
     bb8:	5f 93       	push	r21
     bba:	6f 93       	push	r22
     bbc:	7f 93       	push	r23
     bbe:	8f 93       	push	r24
     bc0:	9f 93       	push	r25
     bc2:	af 93       	push	r26
     bc4:	bf 93       	push	r27
     bc6:	ef 93       	push	r30
     bc8:	ff 93       	push	r31
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	92 dd       	rcall	.-1244   	; 0x6f2 <port_interrupt_handler>
     bce:	ff 91       	pop	r31
     bd0:	ef 91       	pop	r30
     bd2:	bf 91       	pop	r27
     bd4:	af 91       	pop	r26
     bd6:	9f 91       	pop	r25
     bd8:	8f 91       	pop	r24
     bda:	7f 91       	pop	r23
     bdc:	6f 91       	pop	r22
     bde:	5f 91       	pop	r21
     be0:	4f 91       	pop	r20
     be2:	3f 91       	pop	r19
     be4:	2f 91       	pop	r18
     be6:	0f 90       	pop	r0
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	0f 90       	pop	r0
     bec:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:151
    port_interrupt_handler(port); \
  }

IMPLEMENT_ISR(PORTA_PORT_vect, PA)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
IMPLEMENT_ISR(PORTC_PORT_vect, PC)
     bee:	18 95       	reti

00000bf0 <__vector_24>:
__vector_24():
     bf0:	1f 92       	push	r1
     bf2:	0f 92       	push	r0
     bf4:	0f b6       	in	r0, 0x3f	; 63
     bf6:	0f 92       	push	r0
     bf8:	11 24       	eor	r1, r1
     bfa:	2f 93       	push	r18
     bfc:	3f 93       	push	r19
     bfe:	4f 93       	push	r20
     c00:	5f 93       	push	r21
     c02:	6f 93       	push	r22
     c04:	7f 93       	push	r23
     c06:	8f 93       	push	r24
     c08:	9f 93       	push	r25
     c0a:	af 93       	push	r26
     c0c:	bf 93       	push	r27
     c0e:	ef 93       	push	r30
     c10:	ff 93       	push	r31
     c12:	82 e0       	ldi	r24, 0x02	; 2
     c14:	6e dd       	rcall	.-1316   	; 0x6f2 <port_interrupt_handler>
     c16:	ff 91       	pop	r31
     c18:	ef 91       	pop	r30
     c1a:	bf 91       	pop	r27
     c1c:	af 91       	pop	r26
     c1e:	9f 91       	pop	r25
     c20:	8f 91       	pop	r24
     c22:	7f 91       	pop	r23
     c24:	6f 91       	pop	r22
     c26:	5f 91       	pop	r21
     c28:	4f 91       	pop	r20
     c2a:	3f 91       	pop	r19
     c2c:	2f 91       	pop	r18
     c2e:	0f 90       	pop	r0
     c30:	0f be       	out	0x3f, r0	; 63
     c32:	0f 90       	pop	r0
     c34:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:150
  {                               \
    port_interrupt_handler(port); \
  }

IMPLEMENT_ISR(PORTA_PORT_vect, PA)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
     c36:	18 95       	reti

00000c38 <__vector_34>:
__vector_34():
     c38:	1f 92       	push	r1
     c3a:	0f 92       	push	r0
     c3c:	0f b6       	in	r0, 0x3f	; 63
     c3e:	0f 92       	push	r0
     c40:	11 24       	eor	r1, r1
     c42:	2f 93       	push	r18
     c44:	3f 93       	push	r19
     c46:	4f 93       	push	r20
     c48:	5f 93       	push	r21
     c4a:	6f 93       	push	r22
     c4c:	7f 93       	push	r23
     c4e:	8f 93       	push	r24
     c50:	9f 93       	push	r25
     c52:	af 93       	push	r26
     c54:	bf 93       	push	r27
     c56:	ef 93       	push	r30
     c58:	ff 93       	push	r31
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	4a dd       	rcall	.-1388   	; 0x6f2 <port_interrupt_handler>
     c5e:	ff 91       	pop	r31
     c60:	ef 91       	pop	r30
     c62:	bf 91       	pop	r27
     c64:	af 91       	pop	r26
     c66:	9f 91       	pop	r25
     c68:	8f 91       	pop	r24
     c6a:	7f 91       	pop	r23
     c6c:	6f 91       	pop	r22
     c6e:	5f 91       	pop	r21
     c70:	4f 91       	pop	r20
     c72:	3f 91       	pop	r19
     c74:	2f 91       	pop	r18
     c76:	0f 90       	pop	r0
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	0f 90       	pop	r0
     c7c:	1f 90       	pop	r1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:149
  ISR(vect)                       \
  {                               \
    port_interrupt_handler(port); \
  }

IMPLEMENT_ISR(PORTA_PORT_vect, PA)
     c7e:	18 95       	reti

00000c80 <__vector_6>:
__vector_6():
     c80:	1f 92       	push	r1
     c82:	0f 92       	push	r0
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	0f 92       	push	r0
     c88:	11 24       	eor	r1, r1
     c8a:	2f 93       	push	r18
     c8c:	3f 93       	push	r19
     c8e:	4f 93       	push	r20
     c90:	5f 93       	push	r21
     c92:	6f 93       	push	r22
     c94:	7f 93       	push	r23
     c96:	8f 93       	push	r24
     c98:	9f 93       	push	r25
     c9a:	af 93       	push	r26
     c9c:	bf 93       	push	r27
     c9e:	ef 93       	push	r30
     ca0:	ff 93       	push	r31
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	26 dd       	rcall	.-1460   	; 0x6f2 <port_interrupt_handler>
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	bf 91       	pop	r27
     cac:	af 91       	pop	r26
     cae:	9f 91       	pop	r25
     cb0:	8f 91       	pop	r24
     cb2:	7f 91       	pop	r23
     cb4:	6f 91       	pop	r22
     cb6:	5f 91       	pop	r21
     cb8:	4f 91       	pop	r20
     cba:	3f 91       	pop	r19
     cbc:	2f 91       	pop	r18
     cbe:	0f 90       	pop	r0
     cc0:	0f be       	out	0x3f, r0	; 63
     cc2:	0f 90       	pop	r0
     cc4:	1f 90       	pop	r1
     cc6:	18 95       	reti

00000cc8 <SPISettings::SPISettings()>:
_ZN11SPISettingsC2Ev():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:64
      init_MightInline(clock, bitOrder, dataMode);
    }
  }

  // Default speed set to 4MHz, SPI mode set to MODE 0 and Bit order set to MSB first.
  SPISettings() { init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0); }
     cc8:	fc 01       	movw	r30, r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:100
    
    /*  set at run time.                                             */

    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
     cca:	40 e8       	ldi	r20, 0x80	; 128
     ccc:	56 e9       	ldi	r21, 0x96	; 150
     cce:	68 e9       	ldi	r22, 0x98	; 152
     cd0:	70 e0       	ldi	r23, 0x00	; 0
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:101
    clockDiv = 0;
     cd2:	90 e0       	ldi	r25, 0x00	; 0
_ZN11SPISettings17init_AlwaysInlineEmhh():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:104
    while ((clockDiv < 6) && (clock < clockSetting)) {
      clockSetting /= 2;
      clockDiv++;
     cd4:	9f 5f       	subi	r25, 0xFF	; 255
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:102

    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
    clockDiv = 0;
    while ((clockDiv < 6) && (clock < clockSetting)) {
     cd6:	96 30       	cpi	r25, 0x06	; 6
     cd8:	11 f4       	brne	.+4      	; 0xcde <SPISettings::SPISettings()+0x16>
_ZN11SPISettingsC2Ev():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:111
        
    // Compensate for the duplicate fosc/64,
    // should be fosc/128 if clockdiv 6.
    if (clockDiv == 6)
    {
      clockDiv++;
     cda:	97 e0       	ldi	r25, 0x07	; 7
     cdc:	0b c0       	rjmp	.+22     	; 0xcf4 <SPISettings::SPISettings()+0x2c>
_ZN11SPISettings17init_AlwaysInlineEmhh():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:103
    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
    clockDiv = 0;
    while ((clockDiv < 6) && (clock < clockSetting)) {
      clockSetting /= 2;
     cde:	76 95       	lsr	r23
     ce0:	67 95       	ror	r22
     ce2:	57 95       	ror	r21
     ce4:	47 95       	ror	r20
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:102

    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
    clockDiv = 0;
    while ((clockDiv < 6) && (clock < clockSetting)) {
     ce6:	41 30       	cpi	r20, 0x01	; 1
     ce8:	89 e0       	ldi	r24, 0x09	; 9
     cea:	58 07       	cpc	r21, r24
     cec:	8d e3       	ldi	r24, 0x3D	; 61
     cee:	68 07       	cpc	r22, r24
     cf0:	71 05       	cpc	r23, r1
     cf2:	80 f7       	brcc	.-32     	; 0xcd4 <SPISettings::SPISettings()+0xc>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:120
    clockDiv ^= 0x1;
        
    /* Pack into the SPISettings::ctrlb class */
    /* Set mode, disable master slave select, and disable buffering. */
    /* dataMode is register correct, when using SPI_MODE defines     */
    ctrlb = (dataMode)            |
     cf4:	84 e0       	ldi	r24, 0x04	; 4
     cf6:	81 83       	std	Z+1, r24	; 0x01
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:126
            (SPI_SSD_bm)          |
            (0 << SPI_BUFWR_bp)   |
            (0 << SPI_BUFEN_bp);
                
    /* Get Clock related values.*/
    uint8_t clockDiv_mult = (clockDiv & 0x1);
     cf8:	89 2f       	mov	r24, r25
     cfa:	80 95       	com	r24
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:133
        
    /* Pack into the SPISettings::ctrlb class     */
    /* Set Prescaler, x2, SPI to Master, and Bit Order. */
    
    ctrla = (clockDiv_pres  << SPI_PRESC_gp)        |
            (clockDiv_mult << SPI_CLK2X_bp)         |
     cfc:	28 2f       	mov	r18, r24
     cfe:	21 70       	andi	r18, 0x01	; 1
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	84 e0       	ldi	r24, 0x04	; 4
     d04:	22 0f       	add	r18, r18
     d06:	33 1f       	adc	r19, r19
     d08:	8a 95       	dec	r24
     d0a:	e1 f7       	brne	.-8      	; 0xd04 <SPISettings::SPISettings()+0x3c>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:134
            (SPI_ENABLE_bm)                         |
     d0c:	91 62       	ori	r25, 0x21	; 33
     d0e:	92 2b       	or	r25, r18
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:132
    uint8_t clockDiv_pres = (clockDiv >> 1);
        
    /* Pack into the SPISettings::ctrlb class     */
    /* Set Prescaler, x2, SPI to Master, and Bit Order. */
    
    ctrla = (clockDiv_pres  << SPI_PRESC_gp)        |
     d10:	90 83       	st	Z, r25
_ZN11SPISettingsC2Ev():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:64
      init_MightInline(clock, bitOrder, dataMode);
    }
  }

  // Default speed set to 4MHz, SPI mode set to MODE 0 and Bit order set to MSB first.
  SPISettings() { init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0); }
     d12:	08 95       	ret

00000d14 <global constructors keyed to 65535_0_4911_Rocker.cpp.o.2996>:
_GLOBAL__I_65535_0_4911_Rocker.cpp.o.2996():
     d14:	ef 92       	push	r14
     d16:	ff 92       	push	r15
     d18:	0f 93       	push	r16
     d1a:	1f 93       	push	r17
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
     d20:	eb e7       	ldi	r30, 0x7B	; 123
     d22:	f8 e2       	ldi	r31, 0x28	; 40
     d24:	12 82       	std	Z+2, r1	; 0x02
     d26:	13 82       	std	Z+3, r1	; 0x03
     d28:	88 ee       	ldi	r24, 0xE8	; 232
     d2a:	93 e0       	ldi	r25, 0x03	; 3
     d2c:	a0 e0       	ldi	r26, 0x00	; 0
     d2e:	b0 e0       	ldi	r27, 0x00	; 0
     d30:	84 83       	std	Z+4, r24	; 0x04
     d32:	95 83       	std	Z+5, r25	; 0x05
     d34:	a6 83       	std	Z+6, r26	; 0x06
     d36:	b7 83       	std	Z+7, r27	; 0x07
     d38:	88 e5       	ldi	r24, 0x58	; 88
     d3a:	98 e5       	ldi	r25, 0x58	; 88
     d3c:	80 83       	st	Z, r24
     d3e:	91 83       	std	Z+1, r25	; 0x01
     d40:	80 e6       	ldi	r24, 0x60	; 96
     d42:	98 e0       	ldi	r25, 0x08	; 8
     d44:	84 87       	std	Z+12, r24	; 0x0c
     d46:	95 87       	std	Z+13, r25	; 0x0d
     d48:	88 e1       	ldi	r24, 0x18	; 24
     d4a:	86 87       	std	Z+14, r24	; 0x0e
     d4c:	89 e1       	ldi	r24, 0x19	; 25
     d4e:	87 87       	std	Z+15, r24	; 0x0f
     d50:	80 e4       	ldi	r24, 0x40	; 64
     d52:	80 8b       	std	Z+16, r24	; 0x10
     d54:	8a e0       	ldi	r24, 0x0A	; 10
     d56:	81 8b       	std	Z+17, r24	; 0x11
     d58:	89 e0       	ldi	r24, 0x09	; 9
     d5a:	82 8b       	std	Z+18, r24	; 0x12
     d5c:	13 8a       	std	Z+19, r1	; 0x13
     d5e:	14 8a       	std	Z+20, r1	; 0x14
     d60:	15 8a       	std	Z+21, r1	; 0x15
     d62:	16 8a       	std	Z+22, r1	; 0x16
     d64:	17 8a       	std	Z+23, r1	; 0x17
     d66:	10 8e       	std	Z+24, r1	; 0x18
     d68:	11 8e       	std	Z+25, r1	; 0x19
     d6a:	86 e2       	ldi	r24, 0x26	; 38
     d6c:	82 8f       	std	Z+26, r24	; 0x1a
     d6e:	13 8e       	std	Z+27, r1	; 0x1b
     d70:	14 8e       	std	Z+28, r1	; 0x1c
     d72:	88 e1       	ldi	r24, 0x18	; 24
     d74:	99 e2       	ldi	r25, 0x29	; 41
     d76:	a8 df       	rcall	.-176    	; 0xcc8 <SPISettings::SPISettings()>
     d78:	8a e1       	ldi	r24, 0x1A	; 26
     d7a:	e8 2e       	mov	r14, r24
     d7c:	89 e2       	ldi	r24, 0x29	; 41
     d7e:	f8 2e       	mov	r15, r24
     d80:	f7 01       	movw	r30, r14
     d82:	15 82       	std	Z+5, r1	; 0x05
     d84:	82 e0       	ldi	r24, 0x02	; 2
     d86:	84 83       	std	Z+4, r24	; 0x04
     d88:	c9 e5       	ldi	r28, 0x59	; 89
     d8a:	d9 e2       	ldi	r29, 0x29	; 41
     d8c:	0f ef       	ldi	r16, 0xFF	; 255
     d8e:	0b 83       	std	Y+3, r16	; 0x03
     d90:	80 e0       	ldi	r24, 0x00	; 0
     d92:	94 e2       	ldi	r25, 0x24	; 36
     d94:	a4 ef       	ldi	r26, 0xF4	; 244
     d96:	b0 e0       	ldi	r27, 0x00	; 0
     d98:	8d 83       	std	Y+5, r24	; 0x05
     d9a:	9e 83       	std	Y+6, r25	; 0x06
     d9c:	af 83       	std	Y+7, r26	; 0x07
     d9e:	b8 87       	std	Y+8, r27	; 0x08
     da0:	19 8a       	std	Y+17, r1	; 0x11
     da2:	11 e0       	ldi	r17, 0x01	; 1
     da4:	1a 8b       	std	Y+18, r17	; 0x12
     da6:	8e e6       	ldi	r24, 0x6E	; 110
     da8:	99 e2       	ldi	r25, 0x29	; 41
     daa:	8e df       	rcall	.-228    	; 0xcc8 <SPISettings::SPISettings()>
     dac:	eb 8a       	std	Y+19, r14	; 0x13
     dae:	fc 8a       	std	Y+20, r15	; 0x14
     db0:	08 83       	st	Y, r16
     db2:	09 83       	std	Y+1, r16	; 0x01
     db4:	1a 82       	std	Y+2, r1	; 0x02
     db6:	1c 83       	std	Y+4, r17	; 0x04
     db8:	19 87       	std	Y+9, r17	; 0x09
     dba:	18 8b       	std	Y+16, r17	; 0x10
     dbc:	1c 86       	std	Y+12, r1	; 0x0c
     dbe:	1d 86       	std	Y+13, r1	; 0x0d
     dc0:	1e 86       	std	Y+14, r1	; 0x0e
     dc2:	1f 86       	std	Y+15, r1	; 0x0f
     dc4:	19 8a       	std	Y+17, r1	; 0x11
     dc6:	1a 8b       	std	Y+18, r17	; 0x12
     dc8:	8f ef       	ldi	r24, 0xFF	; 255
     dca:	93 e0       	ldi	r25, 0x03	; 3
     dcc:	8a 87       	std	Y+10, r24	; 0x0a
     dce:	9b 87       	std	Y+11, r25	; 0x0b
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	ef 90       	pop	r14
     ddc:	08 95       	ret

00000dde <main>:
main():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/main.cpp:29

void setupUSB() __attribute__((weak));
void setupUSB() {}

int main(void)
{
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	00 d0       	rcall	.+0      	; 0xde4 <main+0x6>
     de4:	cd b7       	in	r28, 0x3d	; 61
     de6:	de b7       	in	r29, 0x3e	; 62
init():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:352
// Use internal oscillator if not defined. No need to manipulate the MCLKCTRLA register here
// because it's already done in the SYSCFG0 fuse byte
#else
#if (F_CPU == 20000000L)
  /* No division on clock */
  _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
     de8:	88 ed       	ldi	r24, 0xD8	; 216
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	84 bf       	out	0x34, r24	; 52
     dee:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7f4061>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:386
#if defined(ADC0)

  /* ADC clock between 50-200 kHz */

#if (F_CPU >= 20000000L) // 20 MHz / 128 = 156.250 kHz
  ADC0.CTRLC |= ADC_PRESC_DIV128_gc;
     df2:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f4602>
     df6:	86 60       	ori	r24, 0x06	; 6
     df8:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f4602>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:402
#else                      // 128 kHz / 2 = 64 kHz -> This is the closest you can get, the prescaler is 2
  ADC0.CTRLC |= ADC_PRESC_DIV2_gc;
#endif

  /* Enable ADC */
  ADC0.CTRLA |= ADC_ENABLE_bm;
     dfc:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f4600>
     e00:	81 60       	ori	r24, 0x01	; 1
     e02:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f4600>
analogReference():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_analog.c:35
{
  switch (mode)
  {
    case EXTERNAL:
    case VDD:
      ADC0.CTRLC = (ADC0.CTRLC & ~(ADC_REFSEL_gm)) | mode | ADC_SAMPCAP_bm; // Per datasheet, recommended SAMPCAP=1 at ref > 1v - we don't *KNOW* the external reference will be >1v, but it's probably more likely...
     e06:	90 91 02 06 	lds	r25, 0x0602	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f4602>
     e0a:	9f 7c       	andi	r25, 0xCF	; 207
     e0c:	90 65       	ori	r25, 0x50	; 80
     e0e:	90 93 02 06 	sts	0x0602, r25	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f4602>
init():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:407
  analogReference(VDD);

#endif

  PORTMUX.USARTROUTEA = 0;
     e12:	10 92 e2 05 	sts	0x05E2, r1	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7f45e2>
setup_timers():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:446
void setup_timers()
{
  //  TYPE A TIMER

  // PORTMUX setting for TCA (defined in pins_arduino.h)
  PORTMUX.TCAROUTEA = TCA0_PINS;
     e16:	81 e0       	ldi	r24, 0x01	; 1
     e18:	80 93 e4 05 	sts	0x05E4, r24	; 0x8005e4 <__TEXT_REGION_LENGTH__+0x7f45e4>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:449

  // Enable split mode before anything else
  TCA0.SPLIT.CTRLD = TCA_SINGLE_SPLITM_bm;
     e1c:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7f4a03>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:453

  // Period setting, two 8 bit registers
  TCA0.SPLIT.LPER =
      TCA0.SPLIT.HPER = PWM_TIMER_PERIOD;
     e20:	8e ef       	ldi	r24, 0xFE	; 254
     e22:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7f4a27>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:452

  // Enable split mode before anything else
  TCA0.SPLIT.CTRLD = TCA_SINGLE_SPLITM_bm;

  // Period setting, two 8 bit registers
  TCA0.SPLIT.LPER =
     e26:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7f4a26>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:461
  TCA0.SPLIT.LCMP0 =
      TCA0.SPLIT.LCMP1 =
          TCA0.SPLIT.LCMP2 =
              TCA0.SPLIT.HCMP0 =
                  TCA0.SPLIT.HCMP1 =
                      TCA0.SPLIT.HCMP2 = PWM_TIMER_COMPARE;
     e2a:	90 e8       	ldi	r25, 0x80	; 128
     e2c:	90 93 2d 0a 	sts	0x0A2D, r25	; 0x800a2d <__TEXT_REGION_LENGTH__+0x7f4a2d>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:460
  // Default duty 50%, will re-assign in analogWrite()
  TCA0.SPLIT.LCMP0 =
      TCA0.SPLIT.LCMP1 =
          TCA0.SPLIT.LCMP2 =
              TCA0.SPLIT.HCMP0 =
                  TCA0.SPLIT.HCMP1 =
     e30:	90 93 2b 0a 	sts	0x0A2B, r25	; 0x800a2b <__TEXT_REGION_LENGTH__+0x7f4a2b>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:459

  // Default duty 50%, will re-assign in analogWrite()
  TCA0.SPLIT.LCMP0 =
      TCA0.SPLIT.LCMP1 =
          TCA0.SPLIT.LCMP2 =
              TCA0.SPLIT.HCMP0 =
     e34:	90 93 29 0a 	sts	0x0A29, r25	; 0x800a29 <__TEXT_REGION_LENGTH__+0x7f4a29>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:458
      TCA0.SPLIT.HPER = PWM_TIMER_PERIOD;

  // Default duty 50%, will re-assign in analogWrite()
  TCA0.SPLIT.LCMP0 =
      TCA0.SPLIT.LCMP1 =
          TCA0.SPLIT.LCMP2 =
     e38:	90 93 2c 0a 	sts	0x0A2C, r25	; 0x800a2c <__TEXT_REGION_LENGTH__+0x7f4a2c>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:457
  TCA0.SPLIT.LPER =
      TCA0.SPLIT.HPER = PWM_TIMER_PERIOD;

  // Default duty 50%, will re-assign in analogWrite()
  TCA0.SPLIT.LCMP0 =
      TCA0.SPLIT.LCMP1 =
     e3c:	90 93 2a 0a 	sts	0x0A2A, r25	; 0x800a2a <__TEXT_REGION_LENGTH__+0x7f4a2a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:456
  // Period setting, two 8 bit registers
  TCA0.SPLIT.LPER =
      TCA0.SPLIT.HPER = PWM_TIMER_PERIOD;

  // Default duty 50%, will re-assign in analogWrite()
  TCA0.SPLIT.LCMP0 =
     e40:	90 93 28 0a 	sts	0x0A28, r25	; 0x800a28 <__TEXT_REGION_LENGTH__+0x7f4a28>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:474
#elif F_CPU <= 8000000L
  // Use DIV16 prescaler (giving 250kHz clocke on 4MHz, 500kHz clock on 8MHz), enable TCA timer
  TCA0.SPLIT.CTRLA = (TCA_SPLIT_CLKSEL_DIV16_gc) | (TCA_SPLIT_ENABLE_bm);
#else
  // Use DIV64 prescaler (giving 250kHz clock on 16MHz), enable TCA timer
  TCA0.SPLIT.CTRLA = (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
     e44:	8b e0       	ldi	r24, 0x0B	; 11
     e46:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7f4a00>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:480
#endif

  //  TYPE B TIMERS

  // Set up routing (defined in pins_arduino.h)
  PORTMUX.TCBROUTEA = 0
     e4a:	83 e0       	ldi	r24, 0x03	; 3
     e4c:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7f45e5>
main():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:496
                      | TCB3_PINS
#endif
      ;

  // Start with TCB0
  TCB_t *timer_B = (TCB_t *)&TCB0;
     e50:	e0 e8       	ldi	r30, 0x80	; 128
     e52:	fa e0       	ldi	r31, 0x0A	; 10
setup_timers():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:513

  // Timer B Setup loop for TCB[0:end]
  do
  {
    // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
    timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
     e54:	37 e0       	ldi	r19, 0x07	; 7
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:516

    // Assign 8-bit period
    timer_B->CCMPL = PWM_TIMER_PERIOD;
     e56:	2e ef       	ldi	r18, 0xFE	; 254
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:523
    // default duty 50%, set when output enabled
    timer_B->CCMPH = PWM_TIMER_COMPARE;

    // Use TCA clock (250kHz) and enable
    // (sync update commented out, might try to synchronize later
    timer_B->CTRLA = (TCB_CLKSEL_CLKTCA_gc)
     e58:	85 e0       	ldi	r24, 0x05	; 5
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:513

  // Timer B Setup loop for TCB[0:end]
  do
  {
    // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
    timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
     e5a:	31 83       	std	Z+1, r19	; 0x01
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:516

    // Assign 8-bit period
    timer_B->CCMPL = PWM_TIMER_PERIOD;
     e5c:	24 87       	std	Z+12, r18	; 0x0c
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:519

    // default duty 50%, set when output enabled
    timer_B->CCMPH = PWM_TIMER_COMPARE;
     e5e:	95 87       	std	Z+13, r25	; 0x0d
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:523

    // Use TCA clock (250kHz) and enable
    // (sync update commented out, might try to synchronize later
    timer_B->CTRLA = (TCB_CLKSEL_CLKTCA_gc)
     e60:	80 83       	st	Z, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:528
                     //|(TCB_SYNCUPD_bm)
                     | (TCB_ENABLE_bm);

    // Increment pointer to next TCB instance
    timer_B++;
     e62:	70 96       	adiw	r30, 0x10	; 16
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:531

    // Stop when pointing to TCB3
  } while (timer_B <= timer_B_end);
     e64:	e0 3c       	cpi	r30, 0xC0	; 192
     e66:	4a e0       	ldi	r20, 0x0A	; 10
     e68:	f4 07       	cpc	r31, r20
     e6a:	b9 f7       	brne	.-18     	; 0xe5a <main+0x7c>
init():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:416
  /********************* TCB for system time tracking **************************/

  // BUG: we can compensate for F_CPU by fine tuning value of TIME_TRACKING_TIMER_COUNT

  /* Select vanilla 16 bit periodic interrupt mode */
  _timer->CTRLB = TCB_CNTMODE_INT_gc;
     e6c:	10 92 b1 0a 	sts	0x0AB1, r1	; 0x800ab1 <__TEXT_REGION_LENGTH__+0x7f4ab1>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:419

  /* TOP value for overflow every N clock cycles */
  _timer->CCMP = TIME_TRACKING_TIMER_COUNT - 1;
     e70:	8f e1       	ldi	r24, 0x1F	; 31
     e72:	9e e4       	ldi	r25, 0x4E	; 78
     e74:	80 93 bc 0a 	sts	0x0ABC, r24	; 0x800abc <__TEXT_REGION_LENGTH__+0x7f4abc>
     e78:	90 93 bd 0a 	sts	0x0ABD, r25	; 0x800abd <__TEXT_REGION_LENGTH__+0x7f4abd>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:422

  /* Enable TCB interrupt */
  _timer->INTCTRL |= TCB_CAPT_bm;
     e7c:	80 91 b5 0a 	lds	r24, 0x0AB5	; 0x800ab5 <__TEXT_REGION_LENGTH__+0x7f4ab5>
     e80:	81 60       	ori	r24, 0x01	; 1
     e82:	80 93 b5 0a 	sts	0x0AB5, r24	; 0x800ab5 <__TEXT_REGION_LENGTH__+0x7f4ab5>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:426

  /* Clock selection is F_CPU/N -- which is independent of TCA */
#if TIME_TRACKING_TIMER_DIVIDER == 1
  _timer->CTRLA = TCB_CLKSEL_CLKDIV1_gc; /* F_CPU */
     e86:	10 92 b0 0a 	sts	0x0AB0, r1	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x7f4ab0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:434
#else
#assert "TIME_TRACKING_TIMER_DIVIDER not supported"
#endif

  /* Enable & start */
  _timer->CTRLA |= TCB_ENABLE_bm; /* Keep this last before enabling interrupts to ensure tracking as accurate as possible */
     e8a:	80 91 b0 0a 	lds	r24, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x7f4ab0>
     e8e:	81 60       	ori	r24, 0x01	; 1
     e90:	80 93 b0 0a 	sts	0x0AB0, r24	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x7f4ab0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring.c:438

  /*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
     e94:	78 94       	sei
pinMode():
     e96:	62 e0       	ldi	r22, 0x02	; 2
     e98:	82 e0       	ldi	r24, 0x02	; 2
     e9a:	56 db       	rcall	.-2388   	; 0x548 <pinMode.part.1>
     e9c:	62 e0       	ldi	r22, 0x02	; 2
     e9e:	84 e0       	ldi	r24, 0x04	; 4
     ea0:	53 db       	rcall	.-2394   	; 0x548 <pinMode.part.1>
     ea2:	61 e0       	ldi	r22, 0x01	; 1
     ea4:	87 e0       	ldi	r24, 0x07	; 7
     ea6:	50 db       	rcall	.-2400   	; 0x548 <pinMode.part.1>
digitalWrite():
     ea8:	60 e0       	ldi	r22, 0x00	; 0
     eaa:	87 e0       	ldi	r24, 0x07	; 7
     eac:	c3 da       	rcall	.-2682   	; 0x434 <digitalWrite.part.2>
setup():
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:78
    pinMode(rocker1, INPUT_PULLUP);
    pinMode(rocker2, INPUT_PULLUP);
    pinMode(buzzerPin, OUTPUT);
    digitalWrite(buzzerPin, buzzerValue);

    Serial.begin(9600);
     eae:	40 e8       	ldi	r20, 0x80	; 128
     eb0:	55 e2       	ldi	r21, 0x25	; 37
     eb2:	60 e0       	ldi	r22, 0x00	; 0
     eb4:	70 e0       	ldi	r23, 0x00	; 0
     eb6:	8b e7       	ldi	r24, 0x7B	; 123
     eb8:	98 e2       	ldi	r25, 0x28	; 40
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:42
}


void MCP_DAC::begin(uint8_t select)
{
  _select = select;
     eba:	4f dd       	rcall	.-1378   	; 0x95a <UartClass::begin(unsigned long)>
begin():
     ebc:	88 e0       	ldi	r24, 0x08	; 8
     ebe:	80 93 5b 29 	sts	0x295B, r24	; 0x80295b <MCP+0x2>
pinMode():
     ec2:	61 e0       	ldi	r22, 0x01	; 1
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:44
  pinMode(_select, OUTPUT);
  digitalWrite(_select, HIGH);
     ec4:	41 db       	rcall	.-2430   	; 0x548 <pinMode.part.1>
begin():
     ec6:	61 e0       	ldi	r22, 0x01	; 1
     ec8:	80 91 5b 29 	lds	r24, 0x295B	; 0x80295b <MCP+0x2>
     ecc:	16 db       	rcall	.-2516   	; 0x4fa <digitalWrite>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:46

  _spi_settings = SPISettings(_SPIspeed, MSBFIRST, SPI_MODE0);
     ece:	80 90 5e 29 	lds	r8, 0x295E	; 0x80295e <MCP+0x5>
     ed2:	90 90 5f 29 	lds	r9, 0x295F	; 0x80295f <MCP+0x6>
     ed6:	a0 90 60 29 	lds	r10, 0x2960	; 0x802960 <MCP+0x7>
     eda:	b0 90 61 29 	lds	r11, 0x2961	; 0x802961 <MCP+0x8>
main():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:100
    
    /*  set at run time.                                             */

    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
     ede:	40 e8       	ldi	r20, 0x80	; 128
     ee0:	56 e9       	ldi	r21, 0x96	; 150
     ee2:	68 e9       	ldi	r22, 0x98	; 152
     ee4:	70 e0       	ldi	r23, 0x00	; 0
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:101
    clockDiv = 0;
     ee6:	80 e0       	ldi	r24, 0x00	; 0
_ZN11SPISettings17init_AlwaysInlineEmhh():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:102
    while ((clockDiv < 6) && (clock < clockSetting)) {
     ee8:	84 16       	cp	r8, r20
     eea:	95 06       	cpc	r9, r21
     eec:	a6 06       	cpc	r10, r22
     eee:	b7 06       	cpc	r11, r23
     ef0:	40 f4       	brcc	.+16     	; 0xf02 <main+0x124>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:103
      clockSetting /= 2;
     ef2:	76 95       	lsr	r23
     ef4:	67 95       	ror	r22
     ef6:	57 95       	ror	r21
     ef8:	47 95       	ror	r20
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:104
      clockDiv++;
     efa:	8f 5f       	subi	r24, 0xFF	; 255
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:102

    uint32_t clockSetting = 0; 
    
    clockSetting = F_CPU / 2;
    clockDiv = 0;
    while ((clockDiv < 6) && (clock < clockSetting)) {
     efc:	86 30       	cpi	r24, 0x06	; 6
     efe:	a1 f7       	brne	.-24     	; 0xee8 <main+0x10a>
main():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:111
        
    // Compensate for the duplicate fosc/64,
    // should be fosc/128 if clockdiv 6.
    if (clockDiv == 6)
    {
      clockDiv++;
     f00:	87 e0       	ldi	r24, 0x07	; 7
_ZN11SPISettings17init_AlwaysInlineEmhh():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:126
            (SPI_SSD_bm)          |
            (0 << SPI_BUFWR_bp)   |
            (0 << SPI_BUFEN_bp);
                
    /* Get Clock related values.*/
    uint8_t clockDiv_mult = (clockDiv & 0x1);
     f02:	98 2f       	mov	r25, r24
     f04:	90 95       	com	r25
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:133
        
    /* Pack into the SPISettings::ctrlb class     */
    /* Set Prescaler, x2, SPI to Master, and Bit Order. */
    
    ctrla = (clockDiv_pres  << SPI_PRESC_gp)        |
            (clockDiv_mult << SPI_CLK2X_bp)         |
     f06:	90 fb       	bst	r25, 0
     f08:	ee 24       	eor	r14, r14
     f0a:	e0 f8       	bld	r14, 0
     f0c:	f1 2c       	mov	r15, r1
     f0e:	44 e0       	ldi	r20, 0x04	; 4
     f10:	ee 0c       	add	r14, r14
     f12:	ff 1c       	adc	r15, r15
     f14:	4a 95       	dec	r20
     f16:	e1 f7       	brne	.-8      	; 0xf10 <main+0x132>
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\spi\src/spi.h:134
            (SPI_ENABLE_bm)                         |
     f18:	81 62       	ori	r24, 0x21	; 33
     f1a:	8e 29       	or	r24, r14
begin():
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:46
     f1c:	80 93 6e 29 	sts	0x296E, r24	; 0x80296e <MCP+0x15>
     f20:	84 e0       	ldi	r24, 0x04	; 4
     f22:	80 93 6f 29 	sts	0x296F, r24	; 0x80296f <MCP+0x16>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:48

  if (_hwSPI)
     f26:	80 91 5d 29 	lds	r24, 0x295D	; 0x80295d <MCP+0x4>
     f2a:	88 23       	and	r24, r24
     f2c:	09 f4       	brne	.+2      	; 0xf30 <main+0x152>
     f2e:	bc c1       	rjmp	.+888    	; 0x12a8 <main+0x4ca>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:65
      mySPI->end();
      mySPI->begin(18, 19, 23, select);   //  CLK=18  MISO=19  MOSI=23
    }

    #else              //  generic hardware SPI
    mySPI->end();
     f30:	e0 91 6c 29 	lds	r30, 0x296C	; 0x80296c <MCP+0x13>
     f34:	f0 91 6d 29 	lds	r31, 0x296D	; 0x80296d <MCP+0x14>
end():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:148
  SPI0.CTRLB = settings.ctrlb;
}

void SPIClass::end()
{
  SPI0.CTRLA &= ~(SPI_ENABLE_bm);
     f38:	80 91 c0 08 	lds	r24, 0x08C0	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
     f3c:	8e 7f       	andi	r24, 0xFE	; 254
     f3e:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:149
  initialized = false;
     f42:	15 82       	std	Z+5, r1	; 0x05
begin():
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:66
    mySPI->begin();
     f44:	e0 91 6c 29 	lds	r30, 0x296C	; 0x80296c <MCP+0x13>
     f48:	f0 91 6d 29 	lds	r31, 0x296D	; 0x80296d <MCP+0x14>
init():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:131
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init()
{
  if (initialized)
     f4c:	85 81       	ldd	r24, Z+5	; 0x05
     f4e:	81 11       	cpse	r24, r1
     f50:	0c c0       	rjmp	.+24     	; 0xf6a <main+0x18c>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:133
    return;
  interruptMode = SPI_IMODE_NONE;
     f52:	16 82       	std	Z+6, r1	; 0x06
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:134
  interruptSave = 0;
     f54:	17 82       	std	Z+7, r1	; 0x07
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:135
  interruptMask_lo = 0;
     f56:	10 86       	std	Z+8, r1	; 0x08
     f58:	11 86       	std	Z+9, r1	; 0x09
     f5a:	12 86       	std	Z+10, r1	; 0x0a
     f5c:	13 86       	std	Z+11, r1	; 0x0b
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:136
  interruptMask_hi = 0;
     f5e:	14 86       	std	Z+12, r1	; 0x0c
     f60:	15 86       	std	Z+13, r1	; 0x0d
     f62:	16 86       	std	Z+14, r1	; 0x0e
     f64:	17 86       	std	Z+15, r1	; 0x0f
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:137
  initialized = true;
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	85 83       	std	Z+5, r24	; 0x05
begin():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:99

void SPIClass::begin()
{
  init();

  PORTMUX.TWISPIROUTEA = _uc_mux | (PORTMUX.TWISPIROUTEA & ~3);
     f6a:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <__TEXT_REGION_LENGTH__+0x7f45e3>
     f6e:	8c 7f       	andi	r24, 0xFC	; 252
     f70:	94 81       	ldd	r25, Z+4	; 0x04
     f72:	89 2b       	or	r24, r25
     f74:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <__TEXT_REGION_LENGTH__+0x7f45e3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:102

  // MISO is set to input by the controller
  if(_uc_mux == SPI_MUX)
     f78:	84 81       	ldd	r24, Z+4	; 0x04
     f7a:	82 30       	cpi	r24, 0x02	; 2
     f7c:	31 f4       	brne	.+12     	; 0xf8a <main+0x1ac>
pinMode():
     f7e:	61 e0       	ldi	r22, 0x01	; 1
     f80:	8b e0       	ldi	r24, 0x0B	; 11
     f82:	e2 da       	rcall	.-2620   	; 0x548 <pinMode.part.1>
     f84:	61 e0       	ldi	r22, 0x01	; 1
     f86:	8d e0       	ldi	r24, 0x0D	; 13
     f88:	df da       	rcall	.-2626   	; 0x548 <pinMode.part.1>
begin():
     f8a:	80 91 c1 08 	lds	r24, 0x08C1	; 0x8008c1 <__TEXT_REGION_LENGTH__+0x7f48c1>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:123
      pinMode(PIN_SPI_SCK_PINSWAP_2, OUTPUT);
    }
  #endif
  
  // We don't need HW SS since salve/master mode is selected via registers
  SPI0.CTRLB |= (SPI_SSD_bm);
     f8e:	84 60       	ori	r24, 0x04	; 4
     f90:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <__TEXT_REGION_LENGTH__+0x7f48c1>
     f94:	80 91 c0 08 	lds	r24, 0x08C0	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:124
  SPI0.CTRLA |= (SPI_ENABLE_bm | SPI_MASTER_bm);
     f98:	81 62       	ori	r24, 0x21	; 33
     f9a:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
     f9e:	90 91 18 29 	lds	r25, 0x2918	; 0x802918 <DEFAULT_SPI_SETTINGS>
     fa2:	80 91 19 29 	lds	r24, 0x2919	; 0x802919 <DEFAULT_SPI_SETTINGS+0x1>
config():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:142
  initialized = true;
}

void SPIClass::config(SPISettings settings)
{
  SPI0.CTRLA = settings.ctrla;
     fa6:	90 93 c0 08 	sts	0x08C0, r25	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:143
  SPI0.CTRLB = settings.ctrlb;
     faa:	80 93 c1 08 	sts	0x08C1, r24	; 0x8008c1 <__TEXT_REGION_LENGTH__+0x7f48c1>
_ZN5EERefC2Ei():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:49
}

struct EERef
{
  EERef(const int index)
      : index(index) {}
     fae:	19 82       	std	Y+1, r1	; 0x01
     fb0:	1a 82       	std	Y+2, r1	; 0x02
_ZNK5EERefcvhEv():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
     fb2:	ce 01       	movw	r24, r28
     fb4:	01 96       	adiw	r24, 0x01	; 1
     fb6:	2a dc       	rcall	.-1964   	; 0x80c <EERef::operator*() const>
setup():
     fb8:	80 93 70 28 	sts	0x2870, r24	; 0x802870 <checkEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:85
    MCP.begin(8);

    checkEEPROM = EEPROM.read(checkEEPROMadd);
    // checkEEPROM = checkEEPROM;

    if (checkEEPROM != 144)  // check to see if EEPROM has valid data
     fbc:	80 39       	cpi	r24, 0x90	; 144
     fbe:	09 f4       	brne	.+2      	; 0xfc2 <main+0x1e4>
     fc0:	88 c1       	rjmp	.+784    	; 0x12d2 <main+0x4f4>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:88
    {
        lowadd = lowByte(maxPedaladd);
        highadd = highByte(lowadd + sizeof(unsigned int));
     fc2:	10 92 73 28 	sts	0x2873, r1	; 0x802873 <highadd>
     fc6:	10 92 74 28 	sts	0x2874, r1	; 0x802874 <highadd+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:89
        EEPROM.put(lowadd, maxPedalEEPROM);
     fca:	64 e0       	ldi	r22, 0x04	; 4
     fcc:	78 e2       	ldi	r23, 0x28	; 40
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:90
        EEPROM.put(highadd, maxPedalEEPROM);
     fd2:	8d dc       	rcall	.-1766   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
     fd4:	64 e0       	ldi	r22, 0x04	; 4
     fd6:	78 e2       	ldi	r23, 0x28	; 40
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:93
        lowadd = lowByte(minPedaladd);
        highadd = highByte(lowadd + sizeof(unsigned int));
        EEPROM.put(lowadd, minPedalEEPROM);
     fdc:	88 dc       	rcall	.-1776   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
     fde:	62 e0       	ldi	r22, 0x02	; 2
     fe0:	78 e2       	ldi	r23, 0x28	; 40
     fe2:	83 e0       	ldi	r24, 0x03	; 3
     fe4:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:94
        EEPROM.put(highadd, minPedalEEPROM);
     fe6:	83 dc       	rcall	.-1786   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
     fe8:	62 e0       	ldi	r22, 0x02	; 2
     fea:	78 e2       	ldi	r23, 0x28	; 40
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	80 e0       	ldi	r24, 0x00	; 0
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:57

  //Assignment/write members.
  EERef &operator=(const EERef &ref) { return *this = *ref; }
  EERef &operator=(uint8_t in) { return nvm_write_byte(index, in), *this; }
     ff0:	7e dc       	rcall	.-1796   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
operator=():
     ff2:	60 e9       	ldi	r22, 0x90	; 144
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:98
        EEPROM.write(checkEEPROMadd, checkEEPROMval);
        lowadd = lowByte(rockervalEEPROMadd);
        highadd = highByte(lowadd + sizeof(unsigned int));
        EEPROM.put(lowadd, rockervalEEPROM);
     ff8:	3e dc       	rcall	.-1924   	; 0x876 <nvm_write_byte(unsigned int, unsigned char)>
setup():
     ffa:	66 e0       	ldi	r22, 0x06	; 6
     ffc:	78 e2       	ldi	r23, 0x28	; 40
     ffe:	85 e0       	ldi	r24, 0x05	; 5
    1000:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:99
        EEPROM.put(highadd, rockervalEEPROM);
    1002:	75 dc       	rcall	.-1814   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
    1004:	66 e0       	ldi	r22, 0x06	; 6
    1006:	78 e2       	ldi	r23, 0x28	; 40
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:100
        EEPROM.update(maxPedaladd, maxPedalEEPROM);
    100c:	70 dc       	rcall	.-1824   	; 0x8ee <unsigned int const& EEPROMClass::put<unsigned int>(int, unsigned int const&) [clone .isra.5]>
    100e:	60 91 04 28 	lds	r22, 0x2804	; 0x802804 <maxPedalEEPROM>
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	48 dc       	rcall	.-1904   	; 0x8a8 <EEPROMClass::update(int, unsigned char) [clone .isra.3]>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:101
        EEPROM.update(minPedaladd, minPedalEEPROM);
    1018:	60 91 02 28 	lds	r22, 0x2802	; 0x802802 <minPedalEEPROM>
    101c:	83 e0       	ldi	r24, 0x03	; 3
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	43 dc       	rcall	.-1914   	; 0x8a8 <EEPROMClass::update(int, unsigned char) [clone .isra.3]>
    1022:	60 e9       	ldi	r22, 0x90	; 144
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:102
        EEPROM.update(checkEEPROMadd, checkEEPROMval);
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	3f dc       	rcall	.-1922   	; 0x8a8 <EEPROMClass::update(int, unsigned char) [clone .isra.3]>
    102a:	60 91 06 28 	lds	r22, 0x2806	; 0x802806 <rockervalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:103
        EEPROM.update(rockervalEEPROMadd, rockervalEEPROM);
    102e:	85 e0       	ldi	r24, 0x05	; 5
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	3a dc       	rcall	.-1932   	; 0x8a8 <EEPROMClass::update(int, unsigned char) [clone .isra.3]>
    1034:	80 91 04 28 	lds	r24, 0x2804	; 0x802804 <maxPedalEEPROM>
    1038:	90 91 05 28 	lds	r25, 0x2805	; 0x802805 <maxPedalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:113
        EEPROM.get(minPedaladd, minPedalEEPROM);
        EEPROM.get(checkEEPROMadd, checkEEPROM);
        EEPROM.get(rockervalEEPROMadd, rockervalEEPROM);
    }

    maxPedal = maxPedalEEPROM;
    103c:	80 93 71 28 	sts	0x2871, r24	; 0x802871 <maxPedal>
    1040:	90 93 72 28 	sts	0x2872, r25	; 0x802872 <maxPedal+0x1>
    1044:	80 91 02 28 	lds	r24, 0x2802	; 0x802802 <minPedalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:114
    minPedal = minPedalEEPROM;
    1048:	90 91 03 28 	lds	r25, 0x2803	; 0x802803 <minPedalEEPROM+0x1>
    104c:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
    1050:	90 93 01 28 	sts	0x2801, r25	; 0x802801 <__DATA_REGION_ORIGIN__+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:115
    rockerval = rockervalEEPROM;
    1054:	80 91 06 28 	lds	r24, 0x2806	; 0x802806 <rockervalEEPROM>
    1058:	90 91 07 28 	lds	r25, 0x2807	; 0x802807 <rockervalEEPROM+0x1>
    105c:	80 93 75 28 	sts	0x2875, r24	; 0x802875 <rockerval>
    1060:	90 93 76 28 	sts	0x2876, r25	; 0x802876 <rockerval+0x1>
print():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:79
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long)b, base);
    1064:	60 91 70 28 	lds	r22, 0x2870	; 0x802870 <checkEEPROM>
    1068:	70 e0       	ldi	r23, 0x00	; 0
    106a:	90 e0       	ldi	r25, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:119
size_t Print::print(unsigned long n, int base)
{
  if (base == 0)
    return write(n);
  else
    return printNumber(n, base);
    106c:	80 e0       	ldi	r24, 0x00	; 0
    106e:	4a e0       	ldi	r20, 0x0A	; 10
    1070:	7d dc       	rcall	.-1798   	; 0x96c <Print::printNumber(unsigned long, unsigned char) [clone .constprop.19]>
println():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Print.cpp:168
}

size_t Print::println(unsigned char b, int base)
{
  size_t n = print(b, base);
  n += println();
    1072:	c2 dc       	rcall	.-1660   	; 0x9f8 <Print::println() [clone .constprop.21]>
setup():
    1074:	80 91 04 28 	lds	r24, 0x2804	; 0x802804 <maxPedalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:118

    Serial.println(checkEEPROM);
    Serial.println(maxPedalEEPROM);
    1078:	90 91 05 28 	lds	r25, 0x2805	; 0x802805 <maxPedalEEPROM+0x1>
    107c:	c4 dc       	rcall	.-1656   	; 0xa06 <Print::println(unsigned int, int) [clone .constprop.15]>
    107e:	80 91 02 28 	lds	r24, 0x2802	; 0x802802 <minPedalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:119
    Serial.println(minPedalEEPROM);
    1082:	90 91 03 28 	lds	r25, 0x2803	; 0x802803 <minPedalEEPROM+0x1>
    1086:	bf dc       	rcall	.-1666   	; 0xa06 <Print::println(unsigned int, int) [clone .constprop.15]>
    1088:	80 91 06 28 	lds	r24, 0x2806	; 0x802806 <rockervalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:120
    Serial.println(rockervalEEPROM);
    108c:	90 91 07 28 	lds	r25, 0x2807	; 0x802807 <rockervalEEPROM+0x1>
    1090:	ba dc       	rcall	.-1676   	; 0xa06 <Print::println(unsigned int, int) [clone .constprop.15]>
attachInterrupt():
    1092:	8a ea       	ldi	r24, 0xAA	; 170
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:47
  uint8_t interruptNum = (digitalPinToPort(pin) * 8) + bit_pos;

  /* Check interrupt number and apply function pointer to correct array index */
  if (interruptNum < EXTERNAL_NUM_INTERRUPTS)
  {
    intFunc[interruptNum] = userFunc;
    1094:	93 e0       	ldi	r25, 0x03	; 3
    1096:	80 93 12 28 	sts	0x2812, r24	; 0x802812 <intFunc>
    109a:	90 93 13 28 	sts	0x2813, r25	; 0x802813 <intFunc+0x1>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:80
    /* Get pointer to correct pin control register */
    PORT_t *port = digitalPinToPortStruct(pin);
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Clear any previous setting */
    *pin_ctrl_reg &= ~(PORT_ISC_gm);
    109e:	80 91 10 04 	lds	r24, 0x0410	; 0x800410 <__TEXT_REGION_LENGTH__+0x7f4410>
    10a2:	88 7f       	andi	r24, 0xF8	; 248
    10a4:	80 93 10 04 	sts	0x0410, r24	; 0x800410 <__TEXT_REGION_LENGTH__+0x7f4410>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/WInterrupts.c:83

    /* Apply ISC setting */
    *pin_ctrl_reg |= mode;
    10a8:	80 91 10 04 	lds	r24, 0x0410	; 0x800410 <__TEXT_REGION_LENGTH__+0x7f4410>
    10ac:	83 60       	ori	r24, 0x03	; 3
    10ae:	80 93 10 04 	sts	0x0410, r24	; 0x800410 <__TEXT_REGION_LENGTH__+0x7f4410>
digitalWrite():
    10b2:	60 e0       	ldi	r22, 0x00	; 0
    10b4:	87 e0       	ldi	r24, 0x07	; 7
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:131

void loop() {
    // Serial.println(analogRead(A0));
    digitalWrite(buzzerPin, 0);

    pedalValue = analogRead(pedalPin);
    10b6:	be d9       	rcall	.-3204   	; 0x434 <digitalWrite.part.2>
loop():
    10b8:	81 e1       	ldi	r24, 0x11	; 17
    10ba:	ff da       	rcall	.-2562   	; 0x6ba <analogRead>
    10bc:	7c 01       	movw	r14, r24
    10be:	80 93 79 28 	sts	0x2879, r24	; 0x802879 <pedalValue>
    10c2:	90 93 7a 28 	sts	0x287A, r25	; 0x80287a <pedalValue+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:132
    grayValue = analogRead(grayPin);
    10c6:	84 e1       	ldi	r24, 0x14	; 20
    10c8:	f8 da       	rcall	.-2576   	; 0x6ba <analogRead>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:133
    purpleValue = analogRead(purplePin);
    10ca:	85 e1       	ldi	r24, 0x15	; 21
    10cc:	f6 da       	rcall	.-2580   	; 0x6ba <analogRead>
    10ce:	6c 01       	movw	r12, r24
    10d0:	80 93 77 28 	sts	0x2877, r24	; 0x802877 <purpleValue>
    10d4:	90 93 78 28 	sts	0x2878, r25	; 0x802878 <purpleValue+0x1>
    10d8:	66 e0       	ldi	r22, 0x06	; 6
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:137

    // pedalValue = (float)map(pedalValue, minPedal, maxPedal, basethrottle,
    // maxPedal);
    EEPROM.get(rockervalEEPROMadd, rockervalEEPROM);
    10da:	78 e2       	ldi	r23, 0x28	; 40
    10dc:	85 e0       	ldi	r24, 0x05	; 5
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	a5 db       	rcall	.-2230   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
    10e2:	64 e0       	ldi	r22, 0x04	; 4
    10e4:	78 e2       	ldi	r23, 0x28	; 40
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:138
    EEPROM.get(maxPedaladd, maxPedalEEPROM);
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	a0 db       	rcall	.-2240   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
    10ec:	62 e0       	ldi	r22, 0x02	; 2
    10ee:	78 e2       	ldi	r23, 0x28	; 40
    10f0:	83 e0       	ldi	r24, 0x03	; 3
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:139
    EEPROM.get(minPedaladd, minPedalEEPROM);
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	9b db       	rcall	.-2250   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
    10f6:	80 91 06 28 	lds	r24, 0x2806	; 0x802806 <rockervalEEPROM>
    10fa:	90 91 07 28 	lds	r25, 0x2807	; 0x802807 <rockervalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:141

    if (rockerval > (rockervalEEPROM + 10) ||
    10fe:	20 91 75 28 	lds	r18, 0x2875	; 0x802875 <rockerval>
    1102:	30 91 76 28 	lds	r19, 0x2876	; 0x802876 <rockerval+0x1>
    1106:	ac 01       	movw	r20, r24
    1108:	46 5f       	subi	r20, 0xF6	; 246
    110a:	5f 4f       	sbci	r21, 0xFF	; 255
    110c:	42 17       	cp	r20, r18
    110e:	53 07       	cpc	r21, r19
    1110:	20 f0       	brcs	.+8      	; 0x111a <main+0x33c>
    1112:	0a 97       	sbiw	r24, 0x0a	; 10
    1114:	28 17       	cp	r18, r24
    1116:	39 07       	cpc	r19, r25
    1118:	40 f4       	brcc	.+16     	; 0x112a <main+0x34c>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:142
        rockerval < (rockervalEEPROM - 10)) {
    111a:	10 92 73 28 	sts	0x2873, r1	; 0x802873 <highadd>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:141
    // maxPedal);
    EEPROM.get(rockervalEEPROMadd, rockervalEEPROM);
    EEPROM.get(maxPedaladd, maxPedalEEPROM);
    EEPROM.get(minPedaladd, minPedalEEPROM);

    if (rockerval > (rockervalEEPROM + 10) ||
    111e:	10 92 74 28 	sts	0x2874, r1	; 0x802874 <highadd+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:144
        rockerval < (rockervalEEPROM - 10)) {
        lowadd = lowByte(rockervalEEPROMadd);
        highadd = highByte(lowadd + sizeof(unsigned int));
    1122:	20 93 06 28 	sts	0x2806, r18	; 0x802806 <rockervalEEPROM>
    1126:	30 93 07 28 	sts	0x2807, r19	; 0x802807 <rockervalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:145
        rockervalEEPROM = rockerval;
    112a:	80 91 04 28 	lds	r24, 0x2804	; 0x802804 <maxPedalEEPROM>
    112e:	90 91 05 28 	lds	r25, 0x2805	; 0x802805 <maxPedalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:150
    }

    // pedalValue = pedalValue + rockerval;

    if (pedalValue > (maxPedalEEPROM + 10) ||
    1132:	9c 01       	movw	r18, r24
    1134:	26 5f       	subi	r18, 0xF6	; 246
    1136:	3f 4f       	sbci	r19, 0xFF	; 255
    1138:	2e 15       	cp	r18, r14
    113a:	3f 05       	cpc	r19, r15
    113c:	20 f0       	brcs	.+8      	; 0x1146 <main+0x368>
    113e:	0a 97       	sbiw	r24, 0x0a	; 10
    1140:	e8 16       	cp	r14, r24
    1142:	f9 06       	cpc	r15, r25
    1144:	40 f4       	brcc	.+16     	; 0x1156 <main+0x378>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:151
        pedalValue < (maxPedalEEPROM - 10)) {
    1146:	10 92 73 28 	sts	0x2873, r1	; 0x802873 <highadd>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:150
        rockervalEEPROM = rockerval;
    }

    // pedalValue = pedalValue + rockerval;

    if (pedalValue > (maxPedalEEPROM + 10) ||
    114a:	10 92 74 28 	sts	0x2874, r1	; 0x802874 <highadd+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:153
        pedalValue < (maxPedalEEPROM - 10)) {
        lowadd = lowByte(maxPedaladd);
        highadd = highByte(lowadd + sizeof(unsigned int));
    114e:	e0 92 04 28 	sts	0x2804, r14	; 0x802804 <maxPedalEEPROM>
    1152:	f0 92 05 28 	sts	0x2805, r15	; 0x802805 <maxPedalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:154
        maxPedalEEPROM = pedalValue;
    1156:	80 91 02 28 	lds	r24, 0x2802	; 0x802802 <minPedalEEPROM>
    115a:	90 91 03 28 	lds	r25, 0x2803	; 0x802803 <minPedalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:157
    }

    if (pedalValue > (minPedalEEPROM + 10) ||
    115e:	9c 01       	movw	r18, r24
    1160:	26 5f       	subi	r18, 0xF6	; 246
    1162:	3f 4f       	sbci	r19, 0xFF	; 255
    1164:	2e 15       	cp	r18, r14
    1166:	3f 05       	cpc	r19, r15
    1168:	20 f0       	brcs	.+8      	; 0x1172 <main+0x394>
    116a:	0a 97       	sbiw	r24, 0x0a	; 10
    116c:	e8 16       	cp	r14, r24
    116e:	f9 06       	cpc	r15, r25
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:158
        pedalValue < (minPedalEEPROM - 10)) {
    1170:	40 f4       	brcc	.+16     	; 0x1182 <main+0x3a4>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:157
        lowadd = lowByte(maxPedaladd);
        highadd = highByte(lowadd + sizeof(unsigned int));
        maxPedalEEPROM = pedalValue;
    }

    if (pedalValue > (minPedalEEPROM + 10) ||
    1172:	10 92 73 28 	sts	0x2873, r1	; 0x802873 <highadd>
    1176:	10 92 74 28 	sts	0x2874, r1	; 0x802874 <highadd+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:160
        pedalValue < (minPedalEEPROM - 10)) {
        lowadd = lowByte(minPedaladd);
        highadd = highByte(lowadd + sizeof(unsigned int));
    117a:	e0 92 02 28 	sts	0x2802, r14	; 0x802802 <minPedalEEPROM>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:161
        minPedalEEPROM = pedalValue;
    117e:	f0 92 03 28 	sts	0x2803, r15	; 0x802803 <minPedalEEPROM+0x1>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:164
    }
    // try try a lateropen settings later
    pedalValue = (float)map(pedalValue, minPedal, maxPedal, basethrottle,
    1182:	80 90 71 28 	lds	r8, 0x2871	; 0x802871 <maxPedal>
    1186:	90 90 72 28 	lds	r9, 0x2872	; 0x802872 <maxPedal+0x1>
    118a:	b1 2c       	mov	r11, r1
    118c:	a1 2c       	mov	r10, r1
    118e:	40 90 00 28 	lds	r4, 0x2800	; 0x802800 <__DATA_REGION_ORIGIN__>
    1192:	50 90 01 28 	lds	r5, 0x2801	; 0x802801 <__DATA_REGION_ORIGIN__+0x1>
    1196:	71 2c       	mov	r7, r1
    1198:	61 2c       	mov	r6, r1
    119a:	97 01       	movw	r18, r14
    119c:	50 e0       	ldi	r21, 0x00	; 0
    119e:	40 e0       	ldi	r20, 0x00	; 0
map():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\\api\/Common.cpp:6
#include "Common.h"

/* C++ prototypes */
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    11a0:	24 19       	sub	r18, r4
    11a2:	35 09       	sbc	r19, r5
    11a4:	46 09       	sbc	r20, r6
    11a6:	57 09       	sbc	r21, r7
    11a8:	c5 01       	movw	r24, r10
    11aa:	b4 01       	movw	r22, r8
    11ac:	64 d2       	rcall	.+1224   	; 0x1676 <__mulsi3>
    11ae:	a5 01       	movw	r20, r10
    11b0:	94 01       	movw	r18, r8
    11b2:	24 19       	sub	r18, r4
    11b4:	35 09       	sbc	r19, r5
    11b6:	46 09       	sbc	r20, r6
    11b8:	57 09       	sbc	r21, r7
    11ba:	8e d2       	rcall	.+1308   	; 0x16d8 <__divmodsi4>
loop():
    11bc:	ca 01       	movw	r24, r20
    11be:	b9 01       	movw	r22, r18
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:164
    11c0:	f6 d1       	rcall	.+1004   	; 0x15ae <__floatsisf>
    11c2:	c7 d1       	rcall	.+910    	; 0x1552 <__fixunssfsi>
    11c4:	60 93 79 28 	sts	0x2879, r22	; 0x802879 <pedalValue>
    11c8:	70 93 7a 28 	sts	0x287A, r23	; 0x80287a <pedalValue+0x1>
    11cc:	c6 16       	cp	r12, r22
    11ce:	d7 06       	cpc	r13, r23
    11d0:	20 f0       	brcs	.+8      	; 0x11da <main+0x3fc>
    11d2:	60 93 77 28 	sts	0x2877, r22	; 0x802877 <purpleValue>
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:168
        maxPedal);


    if (pedalValue <= purpleValue) {
    11d6:	70 93 78 28 	sts	0x2878, r23	; 0x802878 <purpleValue+0x1>
analogWrite():
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:169
        purpleValue = pedalValue;
    11da:	80 91 62 29 	lds	r24, 0x2962	; 0x802962 <MCP+0x9>
    11de:	88 23       	and	r24, r24
    11e0:	09 f4       	brne	.+2      	; 0x11e4 <main+0x406>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:135
}


bool MCP_DAC::analogWrite(uint16_t value, uint8_t channel)
{
  if (channel >= _channels) return false;
    11e2:	60 c0       	rjmp	.+192    	; 0x12a4 <main+0x4c6>
loop():
    11e4:	80 91 77 28 	lds	r24, 0x2877	; 0x802877 <purpleValue>
    11e8:	90 91 78 28 	lds	r25, 0x2878	; 0x802878 <purpleValue+0x1>
analogWrite():
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:175
    }
    else {
        purpleValue = purpleValue;
    }

    MCP.analogWrite(purpleValue, 0);
    11ec:	20 91 63 29 	lds	r18, 0x2963	; 0x802963 <MCP+0xa>
    11f0:	30 91 64 29 	lds	r19, 0x2964	; 0x802964 <MCP+0xb>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:139

  //  CONSTRAIN VALUE
  uint16_t _val = value;
  if (_val > _maxValue) _val = _maxValue;
    11f4:	7c 01       	movw	r14, r24
    11f6:	28 17       	cp	r18, r24
    11f8:	39 07       	cpc	r19, r25
    11fa:	08 f4       	brcc	.+2      	; 0x11fe <main+0x420>
    11fc:	79 01       	movw	r14, r18
    11fe:	80 93 65 29 	sts	0x2965, r24	; 0x802965 <MCP+0xc>
    1202:	90 93 66 29 	sts	0x2966, r25	; 0x802966 <MCP+0xd>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:140
  _value[channel] = value;
    1206:	80 91 6a 29 	lds	r24, 0x296A	; 0x80296a <MCP+0x11>
    120a:	81 11       	cpse	r24, r1
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:145

  //  PREPARING THE DATA TRANSFER
  uint16_t data = 0x1000;
  if (channel == 1) data |= 0x8000;
  if (_buffered)    data |= 0x4000;
    120c:	79 c0       	rjmp	.+242    	; 0x1300 <main+0x522>
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	90 e1       	ldi	r25, 0x10	; 16
    1212:	40 91 69 29 	lds	r20, 0x2969	; 0x802969 <MCP+0x10>
    1216:	41 30       	cpi	r20, 0x01	; 1
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:146
  if (_gain == 1)   data |= 0x2000;
    1218:	09 f4       	brne	.+2      	; 0x121c <main+0x43e>
    121a:	90 62       	ori	r25, 0x20	; 32
    121c:	2f 3f       	cpi	r18, 0xFF	; 255
    121e:	af e0       	ldi	r26, 0x0F	; 15
    1220:	3a 07       	cpc	r19, r26
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:148

  if (_maxValue == 4095)      data |= _val;
    1222:	09 f0       	breq	.+2      	; 0x1226 <main+0x448>
    1224:	70 c0       	rjmp	.+224    	; 0x1306 <main+0x528>
    1226:	e8 2a       	or	r14, r24
    1228:	f9 2a       	or	r15, r25
transfer():
    122a:	60 e0       	ldi	r22, 0x00	; 0
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:150
  else if (_maxValue == 1023) data |= (_val << 2);
  else                        data |= (_val << 4);
    122c:	80 91 5b 29 	lds	r24, 0x295B	; 0x80295b <MCP+0x2>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:305
//  PROTECTED
//
void MCP_DAC::transfer(uint16_t data)
{
  //  DATA TRANSFER
  digitalWrite(_select, LOW);
    1230:	64 d9       	rcall	.-3384   	; 0x4fa <digitalWrite>
    1232:	6f 2c       	mov	r6, r15
    1234:	5e 2c       	mov	r5, r14
    1236:	80 91 5d 29 	lds	r24, 0x295D	; 0x80295d <MCP+0x4>
    123a:	88 23       	and	r24, r24
    123c:	09 f4       	brne	.+2      	; 0x1240 <main+0x462>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:306
  if (_hwSPI)
    123e:	82 c1       	rjmp	.+772    	; 0x1544 <main+0x766>
    1240:	e0 91 6c 29 	lds	r30, 0x296C	; 0x80296c <MCP+0x13>
    1244:	f0 91 6d 29 	lds	r31, 0x296D	; 0x80296d <MCP+0x14>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:309
  {
    //  mySPI->beginTransaction(SPISettings(_SPIspeed, MSBFIRST, SPI_MODE0));
    mySPI->beginTransaction(_spi_settings);
    1248:	10 91 6e 29 	lds	r17, 0x296E	; 0x80296e <MCP+0x15>
    124c:	70 90 6f 29 	lds	r7, 0x296F	; 0x80296f <MCP+0x16>
beginTransaction():
    1250:	86 81       	ldd	r24, Z+6	; 0x06
    1252:	88 23       	and	r24, r24
    1254:	19 f0       	breq	.+6      	; 0x125c <main+0x47e>
    1256:	81 ff       	sbrs	r24, 1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:249
  }
}

void SPIClass::beginTransaction(SPISettings settings)
{
  if (interruptMode != SPI_IMODE_NONE)
    1258:	64 c0       	rjmp	.+200    	; 0x1322 <main+0x544>
    125a:	f8 94       	cli
config():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:251
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    125c:	10 93 c0 08 	sts	0x08C0, r17	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7f48c0>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:253
    {
      noInterrupts();
    1260:	70 92 c1 08 	sts	0x08C1, r7	; 0x8008c1 <__TEXT_REGION_LENGTH__+0x7f48c1>
transfer():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:142
  initialized = true;
}

void SPIClass::config(SPISettings settings)
{
  SPI0.CTRLA = settings.ctrla;
    1264:	00 00       	nop
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:143
  SPI0.CTRLB = settings.ctrlb;
    1266:	60 92 c4 08 	sts	0x08C4, r6	; 0x8008c4 <__TEXT_REGION_LENGTH__+0x7f48c4>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:306
  * about 10% more speed, even if it seems counter-intuitive. At lower
  * speeds it is unnoticed.
  */
  asm volatile("nop");

  SPI0.DATA = data;
    126a:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7f48c3>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:307
  while ((SPI0.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
    126e:	87 ff       	sbrs	r24, 7
    1270:	fc cf       	rjmp	.-8      	; 0x126a <main+0x48c>
    1272:	80 91 c4 08 	lds	r24, 0x08C4	; 0x8008c4 <__TEXT_REGION_LENGTH__+0x7f48c4>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:308
  return SPI0.DATA;                             // read data back
    1276:	00 00       	nop
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:306
  * about 10% more speed, even if it seems counter-intuitive. At lower
  * speeds it is unnoticed.
  */
  asm volatile("nop");

  SPI0.DATA = data;
    1278:	50 92 c4 08 	sts	0x08C4, r5	; 0x8008c4 <__TEXT_REGION_LENGTH__+0x7f48c4>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:307
  while ((SPI0.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
    127c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7f48c3>
    1280:	87 ff       	sbrs	r24, 7
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:308
  return SPI0.DATA;                             // read data back
    1282:	fc cf       	rjmp	.-8      	; 0x127c <main+0x49e>
    1284:	80 91 c4 08 	lds	r24, 0x08C4	; 0x8008c4 <__TEXT_REGION_LENGTH__+0x7f48c4>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:312
    mySPI->transfer((uint8_t)(data >> 8));
    mySPI->transfer((uint8_t)(data & 0xFF));
    mySPI->endTransaction();
    1288:	e0 91 6c 29 	lds	r30, 0x296C	; 0x80296c <MCP+0x13>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:265
  config(settings);
}

void SPIClass::endTransaction(void)
{
  if (interruptMode != SPI_IMODE_NONE)
    128c:	f0 91 6d 29 	lds	r31, 0x296D	; 0x80296d <MCP+0x14>
endTransaction():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:267
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    1290:	86 81       	ldd	r24, Z+6	; 0x06
    1292:	88 23       	and	r24, r24
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:269
    {
        interrupts();
    1294:	19 f0       	breq	.+6      	; 0x129c <main+0x4be>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:319
  else      //  Software SPI
  {
    swSPI_transfer((uint8_t)(data >> 8));
    swSPI_transfer((uint8_t)(data & 0xFF));
  }
  digitalWrite(_select, HIGH);
    1296:	81 ff       	sbrs	r24, 1
    1298:	d0 c0       	rjmp	.+416    	; 0x143a <main+0x65c>
    129a:	78 94       	sei
transfer():
    129c:	61 e0       	ldi	r22, 0x01	; 1
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/main.cpp:43
  setup();

  for (;;)
  {
    loop();
    if (serialEventRun) serialEventRun();
    129e:	80 91 5b 29 	lds	r24, 0x295B	; 0x80295b <MCP+0x2>
    12a2:	2b d9       	rcall	.-3498   	; 0x4fa <digitalWrite>
main():
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:71
    mySPI->begin();
    #endif
  }
  else                 //  software SPI
  {
    pinMode(_dataOut, OUTPUT);
    12a4:	68 d8       	rcall	.-3888   	; 0x376 <serialEventRun()>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:31
    12a6:	05 cf       	rjmp	.-502    	; 0x10b2 <main+0x2d4>
begin():
    12a8:	80 91 59 29 	lds	r24, 0x2959	; 0x802959 <MCP>
pinMode():
    12ac:	8e 32       	cpi	r24, 0x2E	; 46
    12ae:	10 f4       	brcc	.+4      	; 0x12b4 <main+0x4d6>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:72
    pinMode(_clock,   OUTPUT);
    12b0:	61 e0       	ldi	r22, 0x01	; 1
    12b2:	4a d9       	rcall	.-3436   	; 0x548 <pinMode.part.1>
begin():
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\cores\\coreX-corefiles\/wiring_digital.c:31
    12b4:	80 91 5a 29 	lds	r24, 0x295A	; 0x80295a <MCP+0x1>
pinMode():
    12b8:	8e 32       	cpi	r24, 0x2E	; 46
    12ba:	10 f4       	brcc	.+4      	; 0x12c0 <main+0x4e2>
    12bc:	61 e0       	ldi	r22, 0x01	; 1
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:73
    digitalWrite(_dataOut, LOW);
    12be:	44 d9       	rcall	.-3448   	; 0x548 <pinMode.part.1>
begin():
    12c0:	60 e0       	ldi	r22, 0x00	; 0
    12c2:	80 91 59 29 	lds	r24, 0x2959	; 0x802959 <MCP>
    12c6:	19 d9       	rcall	.-3534   	; 0x4fa <digitalWrite>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:74
    digitalWrite(_clock,   LOW);
    12c8:	60 e0       	ldi	r22, 0x00	; 0
    12ca:	80 91 5a 29 	lds	r24, 0x295A	; 0x80295a <MCP+0x1>
    12ce:	15 d9       	rcall	.-3542   	; 0x4fa <digitalWrite>
    12d0:	6e ce       	rjmp	.-804    	; 0xfae <main+0x1d0>
setup():
    12d2:	64 e0       	ldi	r22, 0x04	; 4
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:107
        EEPROM.update(checkEEPROMadd, checkEEPROMval);
        EEPROM.update(rockervalEEPROMadd, rockervalEEPROM);
    }

    else {
        EEPROM.get(maxPedaladd, maxPedalEEPROM);
    12d4:	78 e2       	ldi	r23, 0x28	; 40
    12d6:	81 e0       	ldi	r24, 0x01	; 1
    12d8:	90 e0       	ldi	r25, 0x00	; 0
    12da:	a8 da       	rcall	.-2736   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
    12dc:	62 e0       	ldi	r22, 0x02	; 2
    12de:	78 e2       	ldi	r23, 0x28	; 40
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:108
        EEPROM.get(minPedaladd, minPedalEEPROM);
    12e0:	83 e0       	ldi	r24, 0x03	; 3
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	a3 da       	rcall	.-2746   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
_ZN11EEPROMClass3getIhEERT_iS2_.isra.7():
    12e6:	19 82       	std	Y+1, r1	; 0x01
    12e8:	1a 82       	std	Y+2, r1	; 0x02
_ZNK5EERefcvhEv():
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  template <typename T>
  T &get(int idx, T &t)
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
    12ea:	ce 01       	movw	r24, r28
    12ec:	01 96       	adiw	r24, 0x01	; 1
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:53
  EERef(const int index)
      : index(index) {}

  //Access/read members.
  uint8_t operator*() const { return nvm_read_byte(index); }
  operator uint8_t() const { return **this; }
    12ee:	8e da       	rcall	.-2788   	; 0x80c <EERef::operator*() const>
_ZN11EEPROMClass3getIhEERT_iS2_.isra.7():
    12f0:	80 93 70 28 	sts	0x2870, r24	; 0x802870 <checkEEPROM>
setup():
    12f4:	66 e0       	ldi	r22, 0x06	; 6
c:\users\dan__\appdata\local\arduino15\packages\megacorex\hardware\megaavr\1.1.2\libraries\eeprom\src/eeprom.h:145
  template <typename T>
  T &get(int idx, T &t)
  {
    EEPtr e = idx;
    uint8_t *ptr = (uint8_t *)&t;
    for (int count = sizeof(T); count; --count, ++e) *ptr++ = *e;
    12f6:	78 e2       	ldi	r23, 0x28	; 40
c:\Users\dan__\Documents\Arduino\4911 Rocker\4911 Rocker/4911 Rocker.ino:110
        EEPROM.get(checkEEPROMadd, checkEEPROM);
        EEPROM.get(rockervalEEPROMadd, rockervalEEPROM);
    12f8:	85 e0       	ldi	r24, 0x05	; 5
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	97 da       	rcall	.-2770   	; 0x82c <unsigned int& EEPROMClass::get<unsigned int>(int, unsigned int&) [clone .isra.6]>
    12fe:	9a ce       	rjmp	.-716    	; 0x1034 <main+0x256>
main():
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	90 e5       	ldi	r25, 0x50	; 80
    1304:	86 cf       	rjmp	.-244    	; 0x1212 <main+0x434>
analogWrite():
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:145
  _value[channel] = value;

  //  PREPARING THE DATA TRANSFER
  uint16_t data = 0x1000;
  if (channel == 1) data |= 0x8000;
  if (_buffered)    data |= 0x4000;
    1306:	2f 3f       	cpi	r18, 0xFF	; 255
    1308:	33 40       	sbci	r19, 0x03	; 3
    130a:	29 f4       	brne	.+10     	; 0x1316 <main+0x538>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:149
  if (_gain == 1)   data |= 0x2000;

  if (_maxValue == 4095)      data |= _val;
  else if (_maxValue == 1023) data |= (_val << 2);
    130c:	ee 0c       	add	r14, r14
    130e:	ff 1c       	adc	r15, r15
    1310:	ee 0c       	add	r14, r14
    1312:	ff 1c       	adc	r15, r15
    1314:	88 cf       	rjmp	.-240    	; 0x1226 <main+0x448>
    1316:	24 e0       	ldi	r18, 0x04	; 4
    1318:	ee 0c       	add	r14, r14
    131a:	ff 1c       	adc	r15, r15
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:150
  else                        data |= (_val << 4);
    131c:	2a 95       	dec	r18
    131e:	e1 f7       	brne	.-8      	; 0x1318 <main+0x53a>
    1320:	82 cf       	rjmp	.-252    	; 0x1226 <main+0x448>
beginTransaction():
    1322:	80 ff       	sbrs	r24, 0
    1324:	9b cf       	rjmp	.-202    	; 0x125c <main+0x47e>
detachMaskedInterrupts():
    1326:	80 84       	ldd	r8, Z+8	; 0x08
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:255
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    {
      noInterrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    1328:	91 84       	ldd	r9, Z+9	; 0x09
    132a:	a2 84       	ldd	r10, Z+10	; 0x0a
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:200
    #endif
  }
}

void SPIClass::detachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
    132c:	b3 84       	ldd	r11, Z+11	; 0x0b
    132e:	c1 2c       	mov	r12, r1
    1330:	d1 2c       	mov	r13, r1
    1332:	76 01       	movw	r14, r12
main():
    1334:	41 2c       	mov	r4, r1
detachMaskedInterrupts():
    1336:	94 01       	movw	r18, r8
    1338:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:201
  uint8_t shift = 0;
    133a:	b6 01       	movw	r22, r12
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:202
  while (temp != 0) {
    133c:	c7 01       	movw	r24, r14
    133e:	a0 e0       	ldi	r26, 0x00	; 0
    1340:	14 d2       	rcall	.+1064   	; 0x176a <__cmpdi2_s8>
    1342:	a9 f1       	breq	.+106    	; 0x13ae <main+0x5d0>
    1344:	21 70       	andi	r18, 0x01	; 1
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	40 e0       	ldi	r20, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:203
    if (temp & 1) {
    134a:	50 e0       	ldi	r21, 0x00	; 0
    134c:	60 e0       	ldi	r22, 0x00	; 0
    134e:	70 e0       	ldi	r23, 0x00	; 0
    1350:	80 e0       	ldi	r24, 0x00	; 0
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	0a d2       	rcall	.+1044   	; 0x176a <__cmpdi2_s8>
    1356:	f9 f0       	breq	.+62     	; 0x1396 <main+0x5b8>
    1358:	2f e2       	ldi	r18, 0x2F	; 47
main():
    135a:	90 e0       	ldi	r25, 0x00	; 0
    135c:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
    135e:	24 15       	cp	r18, r4
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:204
      volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift/8), shift%8);
    1360:	70 f0       	brcs	.+28     	; 0x137e <main+0x5a0>
    1362:	84 2d       	mov	r24, r4
    1364:	86 95       	lsr	r24
    1366:	86 95       	lsr	r24
    1368:	86 95       	lsr	r24
    136a:	40 e2       	ldi	r20, 0x20	; 32
    136c:	84 9f       	mul	r24, r20
    136e:	c0 01       	movw	r24, r0
    1370:	11 24       	eor	r1, r1
    1372:	80 5f       	subi	r24, 0xF0	; 240
    1374:	9b 4f       	sbci	r25, 0xFB	; 251
    1376:	24 2d       	mov	r18, r4
    1378:	27 70       	andi	r18, 0x07	; 7
    137a:	82 0f       	add	r24, r18
    137c:	91 1d       	adc	r25, r1
    137e:	dc 01       	movw	r26, r24
    1380:	4c 91       	ld	r20, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:205
      irqMap[shift] = *pin_ctrl_reg;
    1382:	9f 01       	movw	r18, r30
    1384:	24 0d       	add	r18, r4
    1386:	31 1d       	adc	r19, r1
    1388:	d9 01       	movw	r26, r18
    138a:	50 96       	adiw	r26, 0x10	; 16
    138c:	4c 93       	st	X, r20
    138e:	dc 01       	movw	r26, r24
    1390:	2c 91       	ld	r18, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:206
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
    1392:	28 7f       	andi	r18, 0xF8	; 248
    1394:	2c 93       	st	X, r18
    1396:	94 01       	movw	r18, r8
    1398:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:208
    }
    temp = temp >> 1;
    139a:	b6 01       	movw	r22, r12
    139c:	c7 01       	movw	r24, r14
    139e:	01 e0       	ldi	r16, 0x01	; 1
    13a0:	c9 d1       	rcall	.+914    	; 0x1734 <__lshrdi3>
    13a2:	49 01       	movw	r8, r18
    13a4:	5a 01       	movw	r10, r20
    13a6:	6b 01       	movw	r12, r22
    13a8:	7c 01       	movw	r14, r24
    13aa:	43 94       	inc	r4
    13ac:	c4 cf       	rjmp	.-120    	; 0x1336 <main+0x558>
    13ae:	84 84       	ldd	r8, Z+12	; 0x0c
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:209
    shift++;
    13b0:	95 84       	ldd	r9, Z+13	; 0x0d
    13b2:	a6 84       	ldd	r10, Z+14	; 0x0e
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:211
  }
  temp = interruptMask_hi;
    13b4:	b7 84       	ldd	r11, Z+15	; 0x0f
    13b6:	c1 2c       	mov	r12, r1
    13b8:	d1 2c       	mov	r13, r1
    13ba:	76 01       	movw	r14, r12
main():
    13bc:	80 e2       	ldi	r24, 0x20	; 32
    13be:	48 2e       	mov	r4, r24
detachMaskedInterrupts():
    13c0:	94 01       	movw	r18, r8
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:212
  shift = 32;
    13c2:	a5 01       	movw	r20, r10
    13c4:	b6 01       	movw	r22, r12
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:213
  while (temp != 0) {
    13c6:	c7 01       	movw	r24, r14
    13c8:	a0 e0       	ldi	r26, 0x00	; 0
    13ca:	cf d1       	rcall	.+926    	; 0x176a <__cmpdi2_s8>
    13cc:	09 f4       	brne	.+2      	; 0x13d0 <main+0x5f2>
    13ce:	46 cf       	rjmp	.-372    	; 0x125c <main+0x47e>
    13d0:	21 70       	andi	r18, 0x01	; 1
    13d2:	30 e0       	ldi	r19, 0x00	; 0
    13d4:	40 e0       	ldi	r20, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:214
    if (temp & 1) {
    13d6:	50 e0       	ldi	r21, 0x00	; 0
    13d8:	60 e0       	ldi	r22, 0x00	; 0
    13da:	70 e0       	ldi	r23, 0x00	; 0
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	c4 d1       	rcall	.+904    	; 0x176a <__cmpdi2_s8>
    13e2:	f9 f0       	breq	.+62     	; 0x1422 <main+0x644>
    13e4:	bf e2       	ldi	r27, 0x2F	; 47
main():
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	80 e0       	ldi	r24, 0x00	; 0
detachMaskedInterrupts():
    13ea:	b4 15       	cp	r27, r4
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:215
      volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift/8), shift%8);
    13ec:	70 f0       	brcs	.+28     	; 0x140a <main+0x62c>
    13ee:	84 2d       	mov	r24, r4
    13f0:	86 95       	lsr	r24
    13f2:	86 95       	lsr	r24
    13f4:	86 95       	lsr	r24
    13f6:	20 e2       	ldi	r18, 0x20	; 32
    13f8:	82 9f       	mul	r24, r18
    13fa:	c0 01       	movw	r24, r0
    13fc:	11 24       	eor	r1, r1
    13fe:	80 5f       	subi	r24, 0xF0	; 240
    1400:	9b 4f       	sbci	r25, 0xFB	; 251
    1402:	24 2d       	mov	r18, r4
    1404:	27 70       	andi	r18, 0x07	; 7
    1406:	82 0f       	add	r24, r18
    1408:	91 1d       	adc	r25, r1
    140a:	dc 01       	movw	r26, r24
    140c:	4c 91       	ld	r20, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:216
      irqMap[shift] = *pin_ctrl_reg;
    140e:	9f 01       	movw	r18, r30
    1410:	24 0d       	add	r18, r4
    1412:	31 1d       	adc	r19, r1
    1414:	d9 01       	movw	r26, r18
    1416:	50 96       	adiw	r26, 0x10	; 16
    1418:	4c 93       	st	X, r20
    141a:	dc 01       	movw	r26, r24
    141c:	2c 91       	ld	r18, X
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:217
      *pin_ctrl_reg &= ~(PORT_ISC_gm);
    141e:	28 7f       	andi	r18, 0xF8	; 248
    1420:	2c 93       	st	X, r18
    1422:	94 01       	movw	r18, r8
    1424:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:219
    }
    temp = temp >> 1;
    1426:	b6 01       	movw	r22, r12
    1428:	c7 01       	movw	r24, r14
    142a:	01 e0       	ldi	r16, 0x01	; 1
    142c:	83 d1       	rcall	.+774    	; 0x1734 <__lshrdi3>
    142e:	49 01       	movw	r8, r18
    1430:	5a 01       	movw	r10, r20
    1432:	6b 01       	movw	r12, r22
    1434:	7c 01       	movw	r14, r24
    1436:	43 94       	inc	r4
    1438:	c3 cf       	rjmp	.-122    	; 0x13c0 <main+0x5e2>
endTransaction():
    143a:	80 ff       	sbrs	r24, 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:220
    shift++;
    143c:	2f cf       	rjmp	.-418    	; 0x129c <main+0x4be>
reattachMaskedInterrupts():
    143e:	80 84       	ldd	r8, Z+8	; 0x08
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:271
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    {
        interrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    1440:	91 84       	ldd	r9, Z+9	; 0x09
    1442:	a2 84       	ldd	r10, Z+10	; 0x0a
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:225
    shift++;
  }
}

void SPIClass::reattachMaskedInterrupts() {
  uint64_t temp = interruptMask_lo;
    1444:	b3 84       	ldd	r11, Z+11	; 0x0b
    1446:	c1 2c       	mov	r12, r1
    1448:	d1 2c       	mov	r13, r1
    144a:	76 01       	movw	r14, r12
main():
    144c:	10 e0       	ldi	r17, 0x00	; 0
reattachMaskedInterrupts():
    144e:	94 01       	movw	r18, r8
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:226
  uint8_t shift = 0;
    1450:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:227
  while (temp != 0) {
    1452:	b6 01       	movw	r22, r12
    1454:	c7 01       	movw	r24, r14
    1456:	a0 e0       	ldi	r26, 0x00	; 0
    1458:	88 d1       	rcall	.+784    	; 0x176a <__cmpdi2_s8>
    145a:	91 f1       	breq	.+100    	; 0x14c0 <main+0x6e2>
    145c:	21 70       	andi	r18, 0x01	; 1
    145e:	30 e0       	ldi	r19, 0x00	; 0
    1460:	40 e0       	ldi	r20, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:228
    if (temp & 1) {
    1462:	50 e0       	ldi	r21, 0x00	; 0
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	70 e0       	ldi	r23, 0x00	; 0
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	7e d1       	rcall	.+764    	; 0x176a <__cmpdi2_s8>
    146e:	e1 f0       	breq	.+56     	; 0x14a8 <main+0x6ca>
main():
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	80 e0       	ldi	r24, 0x00	; 0
reattachMaskedInterrupts():
    1474:	10 33       	cpi	r17, 0x30	; 48
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:229
      volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift/8), shift%8);
    1476:	70 f4       	brcc	.+28     	; 0x1494 <main+0x6b6>
    1478:	81 2f       	mov	r24, r17
    147a:	86 95       	lsr	r24
    147c:	86 95       	lsr	r24
    147e:	86 95       	lsr	r24
    1480:	b0 e2       	ldi	r27, 0x20	; 32
    1482:	8b 9f       	mul	r24, r27
    1484:	c0 01       	movw	r24, r0
    1486:	11 24       	eor	r1, r1
    1488:	80 5f       	subi	r24, 0xF0	; 240
    148a:	9b 4f       	sbci	r25, 0xFB	; 251
    148c:	21 2f       	mov	r18, r17
    148e:	27 70       	andi	r18, 0x07	; 7
    1490:	82 0f       	add	r24, r18
    1492:	91 1d       	adc	r25, r1
    1494:	9f 01       	movw	r18, r30
    1496:	21 0f       	add	r18, r17
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:230
      *pin_ctrl_reg |= irqMap[shift];
    1498:	31 1d       	adc	r19, r1
    149a:	d9 01       	movw	r26, r18
    149c:	50 96       	adiw	r26, 0x10	; 16
    149e:	2c 91       	ld	r18, X
    14a0:	dc 01       	movw	r26, r24
    14a2:	3c 91       	ld	r19, X
    14a4:	23 2b       	or	r18, r19
    14a6:	2c 93       	st	X, r18
    14a8:	94 01       	movw	r18, r8
    14aa:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:232
    }
    temp = temp >> 1;
    14ac:	b6 01       	movw	r22, r12
    14ae:	c7 01       	movw	r24, r14
    14b0:	01 e0       	ldi	r16, 0x01	; 1
    14b2:	40 d1       	rcall	.+640    	; 0x1734 <__lshrdi3>
    14b4:	49 01       	movw	r8, r18
    14b6:	5a 01       	movw	r10, r20
    14b8:	6b 01       	movw	r12, r22
    14ba:	7c 01       	movw	r14, r24
    14bc:	1f 5f       	subi	r17, 0xFF	; 255
    14be:	c7 cf       	rjmp	.-114    	; 0x144e <main+0x670>
    14c0:	84 84       	ldd	r8, Z+12	; 0x0c
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:233
    shift++;
    14c2:	95 84       	ldd	r9, Z+13	; 0x0d
    14c4:	a6 84       	ldd	r10, Z+14	; 0x0e
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:235
  }
  temp = interruptMask_hi;
    14c6:	b7 84       	ldd	r11, Z+15	; 0x0f
    14c8:	c1 2c       	mov	r12, r1
    14ca:	d1 2c       	mov	r13, r1
    14cc:	76 01       	movw	r14, r12
main():
    14ce:	10 e2       	ldi	r17, 0x20	; 32
reattachMaskedInterrupts():
    14d0:	94 01       	movw	r18, r8
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:236
  shift = 32;
    14d2:	a5 01       	movw	r20, r10
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:237
  while (temp != 0) {
    14d4:	b6 01       	movw	r22, r12
    14d6:	c7 01       	movw	r24, r14
    14d8:	a0 e0       	ldi	r26, 0x00	; 0
    14da:	47 d1       	rcall	.+654    	; 0x176a <__cmpdi2_s8>
    14dc:	09 f4       	brne	.+2      	; 0x14e0 <main+0x702>
    14de:	de ce       	rjmp	.-580    	; 0x129c <main+0x4be>
    14e0:	21 70       	andi	r18, 0x01	; 1
    14e2:	30 e0       	ldi	r19, 0x00	; 0
    14e4:	40 e0       	ldi	r20, 0x00	; 0
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:238
    if (temp & 1) {
    14e6:	50 e0       	ldi	r21, 0x00	; 0
    14e8:	60 e0       	ldi	r22, 0x00	; 0
    14ea:	70 e0       	ldi	r23, 0x00	; 0
    14ec:	80 e0       	ldi	r24, 0x00	; 0
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	3c d1       	rcall	.+632    	; 0x176a <__cmpdi2_s8>
    14f2:	e1 f0       	breq	.+56     	; 0x152c <main+0x74e>
main():
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	80 e0       	ldi	r24, 0x00	; 0
reattachMaskedInterrupts():
    14f8:	10 33       	cpi	r17, 0x30	; 48
    14fa:	70 f4       	brcc	.+28     	; 0x1518 <main+0x73a>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:239
      volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(portToPortStruct(shift/8), shift%8);
    14fc:	81 2f       	mov	r24, r17
    14fe:	86 95       	lsr	r24
    1500:	86 95       	lsr	r24
    1502:	86 95       	lsr	r24
    1504:	b0 e2       	ldi	r27, 0x20	; 32
    1506:	8b 9f       	mul	r24, r27
    1508:	c0 01       	movw	r24, r0
    150a:	11 24       	eor	r1, r1
    150c:	80 5f       	subi	r24, 0xF0	; 240
    150e:	9b 4f       	sbci	r25, 0xFB	; 251
    1510:	21 2f       	mov	r18, r17
    1512:	27 70       	andi	r18, 0x07	; 7
    1514:	82 0f       	add	r24, r18
    1516:	91 1d       	adc	r25, r1
    1518:	9f 01       	movw	r18, r30
    151a:	21 0f       	add	r18, r17
    151c:	31 1d       	adc	r19, r1
    151e:	d9 01       	movw	r26, r18
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:240
      *pin_ctrl_reg |= irqMap[shift];
    1520:	50 96       	adiw	r26, 0x10	; 16
    1522:	2c 91       	ld	r18, X
    1524:	dc 01       	movw	r26, r24
    1526:	3c 91       	ld	r19, X
    1528:	23 2b       	or	r18, r19
    152a:	2c 93       	st	X, r18
    152c:	94 01       	movw	r18, r8
    152e:	a5 01       	movw	r20, r10
    1530:	b6 01       	movw	r22, r12
    1532:	c7 01       	movw	r24, r14
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:242
    }
    temp = temp >> 1;
    1534:	01 e0       	ldi	r16, 0x01	; 1
    1536:	fe d0       	rcall	.+508    	; 0x1734 <__lshrdi3>
    1538:	49 01       	movw	r8, r18
    153a:	5a 01       	movw	r10, r20
    153c:	6b 01       	movw	r12, r22
    153e:	7c 01       	movw	r14, r24
    1540:	1f 5f       	subi	r17, 0xFF	; 255
    1542:	c6 cf       	rjmp	.-116    	; 0x14d0 <main+0x6f2>
transfer():
    1544:	8f 2d       	mov	r24, r15
    1546:	0e 94 81 02 	call	0x502	; 0x502 <MCP_DAC::swSPI_transfer(unsigned char) [clone .constprop.8]>
c:\\Users\\dan__\\AppData\\Local\\Arduino15\\packages\\MegaCoreX\\hardware\\megaavr\\1.1.2\\libraries\\SPI\\src\/SPI.cpp:243
    shift++;
    154a:	8e 2d       	mov	r24, r14
    154c:	0e 94 81 02 	call	0x502	; 0x502 <MCP_DAC::swSPI_transfer(unsigned char) [clone .constprop.8]>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:316
    mySPI->transfer((uint8_t)(data & 0xFF));
    mySPI->endTransaction();
  }
  else      //  Software SPI
  {
    swSPI_transfer((uint8_t)(data >> 8));
    1550:	a5 ce       	rjmp	.-694    	; 0x129c <main+0x4be>

00001552 <__fixunssfsi>:
__fixunssfsi():
    1552:	70 d0       	rcall	.+224    	; 0x1634 <__fp_splitA>
c:\\Users\\dan__\\Documents\\Arduino\\libraries\\MCP_DAC\/MCP_DAC.cpp:317
    swSPI_transfer((uint8_t)(data & 0xFF));
    1554:	88 f0       	brcs	.+34     	; 0x1578 <__fixunssfsi+0x26>
    1556:	9f 57       	subi	r25, 0x7F	; 127
    1558:	90 f0       	brcs	.+36     	; 0x157e <__fixunssfsi+0x2c>
    155a:	b9 2f       	mov	r27, r25
    155c:	99 27       	eor	r25, r25
    155e:	b7 51       	subi	r27, 0x17	; 23
    1560:	a0 f0       	brcs	.+40     	; 0x158a <__fixunssfsi+0x38>
    1562:	d1 f0       	breq	.+52     	; 0x1598 <__fixunssfsi+0x46>
    1564:	66 0f       	add	r22, r22
    1566:	77 1f       	adc	r23, r23
    1568:	88 1f       	adc	r24, r24
    156a:	99 1f       	adc	r25, r25
    156c:	1a f0       	brmi	.+6      	; 0x1574 <__fixunssfsi+0x22>
    156e:	ba 95       	dec	r27
    1570:	c9 f7       	brne	.-14     	; 0x1564 <__fixunssfsi+0x12>
    1572:	12 c0       	rjmp	.+36     	; 0x1598 <__fixunssfsi+0x46>
    1574:	b1 30       	cpi	r27, 0x01	; 1
    1576:	81 f0       	breq	.+32     	; 0x1598 <__fixunssfsi+0x46>
    1578:	77 d0       	rcall	.+238    	; 0x1668 <__fp_zero>
    157a:	b1 e0       	ldi	r27, 0x01	; 1
    157c:	08 95       	ret
    157e:	74 c0       	rjmp	.+232    	; 0x1668 <__fp_zero>
    1580:	67 2f       	mov	r22, r23
    1582:	78 2f       	mov	r23, r24
    1584:	88 27       	eor	r24, r24
    1586:	b8 5f       	subi	r27, 0xF8	; 248
    1588:	39 f0       	breq	.+14     	; 0x1598 <__fixunssfsi+0x46>
    158a:	b9 3f       	cpi	r27, 0xF9	; 249
    158c:	cc f3       	brlt	.-14     	; 0x1580 <__fixunssfsi+0x2e>
    158e:	86 95       	lsr	r24
    1590:	77 95       	ror	r23
    1592:	67 95       	ror	r22
    1594:	b3 95       	inc	r27
    1596:	d9 f7       	brne	.-10     	; 0x158e <__fixunssfsi+0x3c>
    1598:	3e f4       	brtc	.+14     	; 0x15a8 <__fixunssfsi+0x56>
    159a:	90 95       	com	r25
    159c:	80 95       	com	r24
    159e:	70 95       	com	r23
    15a0:	61 95       	neg	r22
    15a2:	7f 4f       	sbci	r23, 0xFF	; 255
    15a4:	8f 4f       	sbci	r24, 0xFF	; 255
    15a6:	9f 4f       	sbci	r25, 0xFF	; 255
    15a8:	08 95       	ret

000015aa <__floatunsisf>:
__floatunsisf():
    15aa:	e8 94       	clt
    15ac:	09 c0       	rjmp	.+18     	; 0x15c0 <__floatsisf+0x12>

000015ae <__floatsisf>:
    15ae:	97 fb       	bst	r25, 7
    15b0:	3e f4       	brtc	.+14     	; 0x15c0 <__floatsisf+0x12>
    15b2:	90 95       	com	r25
    15b4:	80 95       	com	r24
    15b6:	70 95       	com	r23
    15b8:	61 95       	neg	r22
    15ba:	7f 4f       	sbci	r23, 0xFF	; 255
    15bc:	8f 4f       	sbci	r24, 0xFF	; 255
    15be:	9f 4f       	sbci	r25, 0xFF	; 255
    15c0:	99 23       	and	r25, r25
    15c2:	a9 f0       	breq	.+42     	; 0x15ee <__floatsisf+0x40>
    15c4:	f9 2f       	mov	r31, r25
    15c6:	96 e9       	ldi	r25, 0x96	; 150
    15c8:	bb 27       	eor	r27, r27
    15ca:	93 95       	inc	r25
    15cc:	f6 95       	lsr	r31
    15ce:	87 95       	ror	r24
    15d0:	77 95       	ror	r23
    15d2:	67 95       	ror	r22
    15d4:	b7 95       	ror	r27
    15d6:	f1 11       	cpse	r31, r1
    15d8:	f8 cf       	rjmp	.-16     	; 0x15ca <__floatsisf+0x1c>
    15da:	fa f4       	brpl	.+62     	; 0x161a <__floatsisf+0x6c>
    15dc:	bb 0f       	add	r27, r27
    15de:	11 f4       	brne	.+4      	; 0x15e4 <__floatsisf+0x36>
    15e0:	60 ff       	sbrs	r22, 0
    15e2:	1b c0       	rjmp	.+54     	; 0x161a <__floatsisf+0x6c>
    15e4:	6f 5f       	subi	r22, 0xFF	; 255
    15e6:	7f 4f       	sbci	r23, 0xFF	; 255
    15e8:	8f 4f       	sbci	r24, 0xFF	; 255
    15ea:	9f 4f       	sbci	r25, 0xFF	; 255
    15ec:	16 c0       	rjmp	.+44     	; 0x161a <__floatsisf+0x6c>
    15ee:	88 23       	and	r24, r24
    15f0:	11 f0       	breq	.+4      	; 0x15f6 <__floatsisf+0x48>
    15f2:	96 e9       	ldi	r25, 0x96	; 150
    15f4:	11 c0       	rjmp	.+34     	; 0x1618 <__floatsisf+0x6a>
    15f6:	77 23       	and	r23, r23
    15f8:	21 f0       	breq	.+8      	; 0x1602 <__floatsisf+0x54>
    15fa:	9e e8       	ldi	r25, 0x8E	; 142
    15fc:	87 2f       	mov	r24, r23
    15fe:	76 2f       	mov	r23, r22
    1600:	05 c0       	rjmp	.+10     	; 0x160c <__floatsisf+0x5e>
    1602:	66 23       	and	r22, r22
    1604:	71 f0       	breq	.+28     	; 0x1622 <__floatsisf+0x74>
    1606:	96 e8       	ldi	r25, 0x86	; 134
    1608:	86 2f       	mov	r24, r22
    160a:	70 e0       	ldi	r23, 0x00	; 0
    160c:	60 e0       	ldi	r22, 0x00	; 0
    160e:	2a f0       	brmi	.+10     	; 0x161a <__floatsisf+0x6c>
    1610:	9a 95       	dec	r25
    1612:	66 0f       	add	r22, r22
    1614:	77 1f       	adc	r23, r23
    1616:	88 1f       	adc	r24, r24
    1618:	da f7       	brpl	.-10     	; 0x1610 <__floatsisf+0x62>
    161a:	88 0f       	add	r24, r24
    161c:	96 95       	lsr	r25
    161e:	87 95       	ror	r24
    1620:	97 f9       	bld	r25, 7
    1622:	08 95       	ret

00001624 <__fp_split3>:
__fp_split3():
    1624:	57 fd       	sbrc	r21, 7
    1626:	90 58       	subi	r25, 0x80	; 128
    1628:	44 0f       	add	r20, r20
    162a:	55 1f       	adc	r21, r21
    162c:	59 f0       	breq	.+22     	; 0x1644 <__fp_splitA+0x10>
    162e:	5f 3f       	cpi	r21, 0xFF	; 255
    1630:	71 f0       	breq	.+28     	; 0x164e <__fp_splitA+0x1a>
    1632:	47 95       	ror	r20

00001634 <__fp_splitA>:
    1634:	88 0f       	add	r24, r24
    1636:	97 fb       	bst	r25, 7
    1638:	99 1f       	adc	r25, r25
    163a:	61 f0       	breq	.+24     	; 0x1654 <__fp_splitA+0x20>
    163c:	9f 3f       	cpi	r25, 0xFF	; 255
    163e:	79 f0       	breq	.+30     	; 0x165e <__fp_splitA+0x2a>
    1640:	87 95       	ror	r24
    1642:	08 95       	ret
    1644:	12 16       	cp	r1, r18
    1646:	13 06       	cpc	r1, r19
    1648:	14 06       	cpc	r1, r20
    164a:	55 1f       	adc	r21, r21
    164c:	f2 cf       	rjmp	.-28     	; 0x1632 <__fp_split3+0xe>
    164e:	46 95       	lsr	r20
    1650:	f1 df       	rcall	.-30     	; 0x1634 <__fp_splitA>
    1652:	08 c0       	rjmp	.+16     	; 0x1664 <__fp_splitA+0x30>
    1654:	16 16       	cp	r1, r22
    1656:	17 06       	cpc	r1, r23
    1658:	18 06       	cpc	r1, r24
    165a:	99 1f       	adc	r25, r25
    165c:	f1 cf       	rjmp	.-30     	; 0x1640 <__fp_splitA+0xc>
    165e:	86 95       	lsr	r24
    1660:	71 05       	cpc	r23, r1
    1662:	61 05       	cpc	r22, r1
    1664:	08 94       	sec
    1666:	08 95       	ret

00001668 <__fp_zero>:
__fp_zero():
    1668:	e8 94       	clt

0000166a <__fp_szero>:
    166a:	bb 27       	eor	r27, r27
    166c:	66 27       	eor	r22, r22
    166e:	77 27       	eor	r23, r23
    1670:	cb 01       	movw	r24, r22
    1672:	97 f9       	bld	r25, 7
    1674:	08 95       	ret

00001676 <__mulsi3>:
__mulsi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    1676:	db 01       	movw	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    1678:	8f 93       	push	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    167a:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    167c:	49 d0       	rcall	.+146    	; 0x1710 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    167e:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    1680:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    1682:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    1684:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    1686:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    1688:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    168a:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    168c:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    168e:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    1690:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    1692:	08 95       	ret

00001694 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1694:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1696:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1698:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    169a:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    169c:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    169e:	0d c0       	rjmp	.+26     	; 0x16ba <__udivmodsi4_ep>

000016a0 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    16a0:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    16a2:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    16a4:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    16a6:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    16a8:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    16aa:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    16ac:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    16ae:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    16b0:	20 f0       	brcs	.+8      	; 0x16ba <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    16b2:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    16b4:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    16b6:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    16b8:	f5 0b       	sbc	r31, r21

000016ba <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    16ba:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    16bc:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    16be:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    16c0:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    16c2:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    16c4:	69 f7       	brne	.-38     	; 0x16a0 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    16c6:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    16c8:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    16ca:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    16cc:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    16ce:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    16d0:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    16d2:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    16d4:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    16d6:	08 95       	ret

000016d8 <__divmodsi4>:
__divmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    16d8:	05 2e       	mov	r0, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    16da:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    16dc:	16 f4       	brtc	.+4      	; 0x16e2 <__divmodsi4+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    16de:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    16e0:	0f d0       	rcall	.+30     	; 0x1700 <__negsi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    16e2:	57 fd       	sbrc	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    16e4:	05 d0       	rcall	.+10     	; 0x16f0 <__divmodsi4_neg2>
    16e6:	d6 df       	rcall	.-84     	; 0x1694 <__udivmodsi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    16e8:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    16ea:	02 d0       	rcall	.+4      	; 0x16f0 <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    16ec:	46 f4       	brtc	.+16     	; 0x16fe <__divmodsi4_exit>
    16ee:	08 c0       	rjmp	.+16     	; 0x1700 <__negsi2>

000016f0 <__divmodsi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    16f0:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    16f2:	40 95       	com	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    16f4:	30 95       	com	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    16f6:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    16f8:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    16fa:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    16fc:	5f 4f       	sbci	r21, 0xFF	; 255

000016fe <__divmodsi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    16fe:	08 95       	ret

00001700 <__negsi2>:
__negsi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    1700:	90 95       	com	r25
    1702:	80 95       	com	r24
    1704:	70 95       	com	r23
    1706:	61 95       	neg	r22
    1708:	7f 4f       	sbci	r23, 0xFF	; 255
    170a:	8f 4f       	sbci	r24, 0xFF	; 255
    170c:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    170e:	08 95       	ret

00001710 <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1710:	3e d0       	rcall	.+124    	; 0x178e <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    1712:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    1714:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    1716:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    1718:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    171a:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    171c:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    171e:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    1720:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    1722:	08 95       	ret

00001724 <__mulshisi3>:
__mulshisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    1724:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    1726:	f4 cf       	rjmp	.-24     	; 0x1710 <__muluhisi3>

00001728 <__mulohisi3>:
__mulohisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    1728:	f3 df       	rcall	.-26     	; 0x1710 <__muluhisi3>
    172a:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    172c:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    172e:	08 95       	ret

00001730 <__ashrdi3>:
__ashrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    1730:	97 fd       	sbrc	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3123
    1732:	10 94       	com	r1

00001734 <__lshrdi3>:
__lshrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3131
    1734:	00 2e       	mov	r0, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3132
    1736:	08 30       	cpi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3133
    1738:	98 f0       	brcs	.+38     	; 0x1760 <__lshrdi3+0x2c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3134
    173a:	08 50       	subi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3135
    173c:	23 2f       	mov	r18, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3136
    173e:	34 2f       	mov	r19, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3137
    1740:	45 2f       	mov	r20, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3138
    1742:	56 2f       	mov	r21, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3139
    1744:	67 2f       	mov	r22, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3140
    1746:	78 2f       	mov	r23, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3141
    1748:	89 2f       	mov	r24, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3142
    174a:	91 2d       	mov	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3143
    174c:	f4 cf       	rjmp	.-24     	; 0x1736 <__lshrdi3+0x2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3144
    174e:	15 94       	asr	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3145
    1750:	97 95       	ror	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3146
    1752:	87 95       	ror	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3147
    1754:	77 95       	ror	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3148
    1756:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3149
    1758:	57 95       	ror	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3150
    175a:	47 95       	ror	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3151
    175c:	37 95       	ror	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3152
    175e:	27 95       	ror	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3153
    1760:	0a 95       	dec	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3154
    1762:	aa f7       	brpl	.-22     	; 0x174e <__lshrdi3+0x1a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3155
    1764:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3156
    1766:	00 2d       	mov	r16, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3157
    1768:	08 95       	ret

0000176a <__cmpdi2_s8>:
__cmpdi2_s8():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2102
    176a:	00 24       	eor	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2103
    176c:	a7 fd       	sbrc	r26, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2104
    176e:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2105
    1770:	2a 17       	cp	r18, r26
    1772:	30 05       	cpc	r19, r0
    1774:	40 05       	cpc	r20, r0
    1776:	50 05       	cpc	r21, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2106
    1778:	60 05       	cpc	r22, r0
    177a:	70 05       	cpc	r23, r0
    177c:	80 05       	cpc	r24, r0
    177e:	90 05       	cpc	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2107
    1780:	08 95       	ret

00001782 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    1782:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    1784:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    1786:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    1788:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    178a:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    178c:	09 94       	ijmp

0000178e <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    178e:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1790:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    1792:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    1794:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    1796:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    1798:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    179a:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    179c:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    179e:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    17a0:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    17a2:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    17a4:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    17a6:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    17a8:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    17aa:	08 95       	ret

000017ac <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    17ac:	f8 94       	cli

000017ae <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    17ae:	ff cf       	rjmp	.-2      	; 0x17ae <__stop_program>
